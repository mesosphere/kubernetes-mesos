// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mesos.proto

#ifndef PROTOBUF_mesos_2eproto__INCLUDED
#define PROTOBUF_mesos_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace mesos {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_mesos_2eproto();
void protobuf_AssignDesc_mesos_2eproto();
void protobuf_ShutdownFile_mesos_2eproto();

class FrameworkID;
class OfferID;
class SlaveID;
class TaskID;
class ExecutorID;
class ContainerID;
class FrameworkInfo;
class HealthCheck;
class HealthCheck_HTTP;
class CommandInfo;
class CommandInfo_URI;
class CommandInfo_ContainerInfo;
class ExecutorInfo;
class MasterInfo;
class SlaveInfo;
class Value;
class Value_Scalar;
class Value_Range;
class Value_Ranges;
class Value_Set;
class Value_Text;
class Attribute;
class Resource;
class ResourceStatistics;
class ResourceUsage;
class Request;
class Offer;
class TaskInfo;
class TaskStatus;
class Filters;
class Environment;
class Environment_Variable;
class Parameter;
class Parameters;
class Credential;
class ACL;
class ACL_Entity;
class ACL_RunTasks;
class ACL_ReceiveOffers;
class ACL_HTTPGet;
class ACL_HTTPPut;
class ACLs;

enum Value_Type {
  Value_Type_SCALAR = 0,
  Value_Type_RANGES = 1,
  Value_Type_SET = 2,
  Value_Type_TEXT = 3
};
bool Value_Type_IsValid(int value);
const Value_Type Value_Type_Type_MIN = Value_Type_SCALAR;
const Value_Type Value_Type_Type_MAX = Value_Type_TEXT;
const int Value_Type_Type_ARRAYSIZE = Value_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Value_Type_descriptor();
inline const ::std::string& Value_Type_Name(Value_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Value_Type_descriptor(), value);
}
inline bool Value_Type_Parse(
    const ::std::string& name, Value_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Value_Type>(
    Value_Type_descriptor(), name, value);
}
enum ACL_Entity_Type {
  ACL_Entity_Type_SOME = 0,
  ACL_Entity_Type_ANY = 1,
  ACL_Entity_Type_NONE = 2
};
bool ACL_Entity_Type_IsValid(int value);
const ACL_Entity_Type ACL_Entity_Type_Type_MIN = ACL_Entity_Type_SOME;
const ACL_Entity_Type ACL_Entity_Type_Type_MAX = ACL_Entity_Type_NONE;
const int ACL_Entity_Type_Type_ARRAYSIZE = ACL_Entity_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* ACL_Entity_Type_descriptor();
inline const ::std::string& ACL_Entity_Type_Name(ACL_Entity_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    ACL_Entity_Type_descriptor(), value);
}
inline bool ACL_Entity_Type_Parse(
    const ::std::string& name, ACL_Entity_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ACL_Entity_Type>(
    ACL_Entity_Type_descriptor(), name, value);
}
enum Status {
  DRIVER_NOT_STARTED = 1,
  DRIVER_RUNNING = 2,
  DRIVER_ABORTED = 3,
  DRIVER_STOPPED = 4
};
bool Status_IsValid(int value);
const Status Status_MIN = DRIVER_NOT_STARTED;
const Status Status_MAX = DRIVER_STOPPED;
const int Status_ARRAYSIZE = Status_MAX + 1;

const ::google::protobuf::EnumDescriptor* Status_descriptor();
inline const ::std::string& Status_Name(Status value) {
  return ::google::protobuf::internal::NameOfEnum(
    Status_descriptor(), value);
}
inline bool Status_Parse(
    const ::std::string& name, Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Status>(
    Status_descriptor(), name, value);
}
enum TaskState {
  TASK_STAGING = 6,
  TASK_STARTING = 0,
  TASK_RUNNING = 1,
  TASK_FINISHED = 2,
  TASK_FAILED = 3,
  TASK_KILLED = 4,
  TASK_LOST = 5
};
bool TaskState_IsValid(int value);
const TaskState TaskState_MIN = TASK_STARTING;
const TaskState TaskState_MAX = TASK_STAGING;
const int TaskState_ARRAYSIZE = TaskState_MAX + 1;

const ::google::protobuf::EnumDescriptor* TaskState_descriptor();
inline const ::std::string& TaskState_Name(TaskState value) {
  return ::google::protobuf::internal::NameOfEnum(
    TaskState_descriptor(), value);
}
inline bool TaskState_Parse(
    const ::std::string& name, TaskState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TaskState>(
    TaskState_descriptor(), name, value);
}
// ===================================================================

class FrameworkID : public ::google::protobuf::Message {
 public:
  FrameworkID();
  virtual ~FrameworkID();

  FrameworkID(const FrameworkID& from);

  inline FrameworkID& operator=(const FrameworkID& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FrameworkID& default_instance();

  void Swap(FrameworkID* other);

  // implements Message ----------------------------------------------

  FrameworkID* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FrameworkID& from);
  void MergeFrom(const FrameworkID& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:mesos.FrameworkID)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static FrameworkID* default_instance_;
};
// -------------------------------------------------------------------

class OfferID : public ::google::protobuf::Message {
 public:
  OfferID();
  virtual ~OfferID();

  OfferID(const OfferID& from);

  inline OfferID& operator=(const OfferID& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OfferID& default_instance();

  void Swap(OfferID* other);

  // implements Message ----------------------------------------------

  OfferID* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OfferID& from);
  void MergeFrom(const OfferID& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:mesos.OfferID)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static OfferID* default_instance_;
};
// -------------------------------------------------------------------

class SlaveID : public ::google::protobuf::Message {
 public:
  SlaveID();
  virtual ~SlaveID();

  SlaveID(const SlaveID& from);

  inline SlaveID& operator=(const SlaveID& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SlaveID& default_instance();

  void Swap(SlaveID* other);

  // implements Message ----------------------------------------------

  SlaveID* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SlaveID& from);
  void MergeFrom(const SlaveID& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:mesos.SlaveID)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static SlaveID* default_instance_;
};
// -------------------------------------------------------------------

class TaskID : public ::google::protobuf::Message {
 public:
  TaskID();
  virtual ~TaskID();

  TaskID(const TaskID& from);

  inline TaskID& operator=(const TaskID& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskID& default_instance();

  void Swap(TaskID* other);

  // implements Message ----------------------------------------------

  TaskID* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TaskID& from);
  void MergeFrom(const TaskID& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:mesos.TaskID)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static TaskID* default_instance_;
};
// -------------------------------------------------------------------

class ExecutorID : public ::google::protobuf::Message {
 public:
  ExecutorID();
  virtual ~ExecutorID();

  ExecutorID(const ExecutorID& from);

  inline ExecutorID& operator=(const ExecutorID& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExecutorID& default_instance();

  void Swap(ExecutorID* other);

  // implements Message ----------------------------------------------

  ExecutorID* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExecutorID& from);
  void MergeFrom(const ExecutorID& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:mesos.ExecutorID)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static ExecutorID* default_instance_;
};
// -------------------------------------------------------------------

class ContainerID : public ::google::protobuf::Message {
 public:
  ContainerID();
  virtual ~ContainerID();

  ContainerID(const ContainerID& from);

  inline ContainerID& operator=(const ContainerID& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContainerID& default_instance();

  void Swap(ContainerID* other);

  // implements Message ----------------------------------------------

  ContainerID* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ContainerID& from);
  void MergeFrom(const ContainerID& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:mesos.ContainerID)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static ContainerID* default_instance_;
};
// -------------------------------------------------------------------

class FrameworkInfo : public ::google::protobuf::Message {
 public:
  FrameworkInfo();
  virtual ~FrameworkInfo();

  FrameworkInfo(const FrameworkInfo& from);

  inline FrameworkInfo& operator=(const FrameworkInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FrameworkInfo& default_instance();

  void Swap(FrameworkInfo* other);

  // implements Message ----------------------------------------------

  FrameworkInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FrameworkInfo& from);
  void MergeFrom(const FrameworkInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string user = 1;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 1;
  inline const ::std::string& user() const;
  inline void set_user(const ::std::string& value);
  inline void set_user(const char* value);
  inline void set_user(const char* value, size_t size);
  inline ::std::string* mutable_user();
  inline ::std::string* release_user();
  inline void set_allocated_user(::std::string* user);

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .mesos.FrameworkID id = 3;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 3;
  inline const ::mesos::FrameworkID& id() const;
  inline ::mesos::FrameworkID* mutable_id();
  inline ::mesos::FrameworkID* release_id();
  inline void set_allocated_id(::mesos::FrameworkID* id);

  // optional double failover_timeout = 4 [default = 0];
  inline bool has_failover_timeout() const;
  inline void clear_failover_timeout();
  static const int kFailoverTimeoutFieldNumber = 4;
  inline double failover_timeout() const;
  inline void set_failover_timeout(double value);

  // optional bool checkpoint = 5 [default = false];
  inline bool has_checkpoint() const;
  inline void clear_checkpoint();
  static const int kCheckpointFieldNumber = 5;
  inline bool checkpoint() const;
  inline void set_checkpoint(bool value);

  // optional string role = 6 [default = "*"];
  inline bool has_role() const;
  inline void clear_role();
  static const int kRoleFieldNumber = 6;
  inline const ::std::string& role() const;
  inline void set_role(const ::std::string& value);
  inline void set_role(const char* value);
  inline void set_role(const char* value, size_t size);
  inline ::std::string* mutable_role();
  inline ::std::string* release_role();
  inline void set_allocated_role(::std::string* role);

  // optional string hostname = 7;
  inline bool has_hostname() const;
  inline void clear_hostname();
  static const int kHostnameFieldNumber = 7;
  inline const ::std::string& hostname() const;
  inline void set_hostname(const ::std::string& value);
  inline void set_hostname(const char* value);
  inline void set_hostname(const char* value, size_t size);
  inline ::std::string* mutable_hostname();
  inline ::std::string* release_hostname();
  inline void set_allocated_hostname(::std::string* hostname);

  // optional string principal = 8;
  inline bool has_principal() const;
  inline void clear_principal();
  static const int kPrincipalFieldNumber = 8;
  inline const ::std::string& principal() const;
  inline void set_principal(const ::std::string& value);
  inline void set_principal(const char* value);
  inline void set_principal(const char* value, size_t size);
  inline ::std::string* mutable_principal();
  inline ::std::string* release_principal();
  inline void set_allocated_principal(::std::string* principal);

  // @@protoc_insertion_point(class_scope:mesos.FrameworkInfo)
 private:
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_failover_timeout();
  inline void clear_has_failover_timeout();
  inline void set_has_checkpoint();
  inline void clear_has_checkpoint();
  inline void set_has_role();
  inline void clear_has_role();
  inline void set_has_hostname();
  inline void clear_has_hostname();
  inline void set_has_principal();
  inline void clear_has_principal();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* user_;
  ::std::string* name_;
  ::mesos::FrameworkID* id_;
  double failover_timeout_;
  ::std::string* role_;
  static ::std::string* _default_role_;
  ::std::string* hostname_;
  ::std::string* principal_;
  bool checkpoint_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static FrameworkInfo* default_instance_;
};
// -------------------------------------------------------------------

class HealthCheck_HTTP : public ::google::protobuf::Message {
 public:
  HealthCheck_HTTP();
  virtual ~HealthCheck_HTTP();

  HealthCheck_HTTP(const HealthCheck_HTTP& from);

  inline HealthCheck_HTTP& operator=(const HealthCheck_HTTP& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HealthCheck_HTTP& default_instance();

  void Swap(HealthCheck_HTTP* other);

  // implements Message ----------------------------------------------

  HealthCheck_HTTP* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HealthCheck_HTTP& from);
  void MergeFrom(const HealthCheck_HTTP& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 port = 1;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 1;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // optional string path = 2 [default = "/"];
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 2;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // repeated uint32 statuses = 4;
  inline int statuses_size() const;
  inline void clear_statuses();
  static const int kStatusesFieldNumber = 4;
  inline ::google::protobuf::uint32 statuses(int index) const;
  inline void set_statuses(int index, ::google::protobuf::uint32 value);
  inline void add_statuses(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      statuses() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_statuses();

  // @@protoc_insertion_point(class_scope:mesos.HealthCheck.HTTP)
 private:
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_path();
  inline void clear_has_path();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* path_;
  static ::std::string* _default_path_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > statuses_;
  ::google::protobuf::uint32 port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static HealthCheck_HTTP* default_instance_;
};
// -------------------------------------------------------------------

class HealthCheck : public ::google::protobuf::Message {
 public:
  HealthCheck();
  virtual ~HealthCheck();

  HealthCheck(const HealthCheck& from);

  inline HealthCheck& operator=(const HealthCheck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HealthCheck& default_instance();

  void Swap(HealthCheck* other);

  // implements Message ----------------------------------------------

  HealthCheck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HealthCheck& from);
  void MergeFrom(const HealthCheck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef HealthCheck_HTTP HTTP;

  // accessors -------------------------------------------------------

  // optional .mesos.HealthCheck.HTTP http = 1;
  inline bool has_http() const;
  inline void clear_http();
  static const int kHttpFieldNumber = 1;
  inline const ::mesos::HealthCheck_HTTP& http() const;
  inline ::mesos::HealthCheck_HTTP* mutable_http();
  inline ::mesos::HealthCheck_HTTP* release_http();
  inline void set_allocated_http(::mesos::HealthCheck_HTTP* http);

  // optional double delay_seconds = 2 [default = 15];
  inline bool has_delay_seconds() const;
  inline void clear_delay_seconds();
  static const int kDelaySecondsFieldNumber = 2;
  inline double delay_seconds() const;
  inline void set_delay_seconds(double value);

  // optional double interval_seconds = 3 [default = 10];
  inline bool has_interval_seconds() const;
  inline void clear_interval_seconds();
  static const int kIntervalSecondsFieldNumber = 3;
  inline double interval_seconds() const;
  inline void set_interval_seconds(double value);

  // optional double timeout_seconds = 4 [default = 20];
  inline bool has_timeout_seconds() const;
  inline void clear_timeout_seconds();
  static const int kTimeoutSecondsFieldNumber = 4;
  inline double timeout_seconds() const;
  inline void set_timeout_seconds(double value);

  // optional uint32 failures = 5 [default = 3];
  inline bool has_failures() const;
  inline void clear_failures();
  static const int kFailuresFieldNumber = 5;
  inline ::google::protobuf::uint32 failures() const;
  inline void set_failures(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mesos.HealthCheck)
 private:
  inline void set_has_http();
  inline void clear_has_http();
  inline void set_has_delay_seconds();
  inline void clear_has_delay_seconds();
  inline void set_has_interval_seconds();
  inline void clear_has_interval_seconds();
  inline void set_has_timeout_seconds();
  inline void clear_has_timeout_seconds();
  inline void set_has_failures();
  inline void clear_has_failures();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::HealthCheck_HTTP* http_;
  double delay_seconds_;
  double interval_seconds_;
  double timeout_seconds_;
  ::google::protobuf::uint32 failures_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static HealthCheck* default_instance_;
};
// -------------------------------------------------------------------

class CommandInfo_URI : public ::google::protobuf::Message {
 public:
  CommandInfo_URI();
  virtual ~CommandInfo_URI();

  CommandInfo_URI(const CommandInfo_URI& from);

  inline CommandInfo_URI& operator=(const CommandInfo_URI& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandInfo_URI& default_instance();

  void Swap(CommandInfo_URI* other);

  // implements Message ----------------------------------------------

  CommandInfo_URI* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandInfo_URI& from);
  void MergeFrom(const CommandInfo_URI& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // optional bool executable = 2;
  inline bool has_executable() const;
  inline void clear_executable();
  static const int kExecutableFieldNumber = 2;
  inline bool executable() const;
  inline void set_executable(bool value);

  // optional bool extract = 3 [default = true];
  inline bool has_extract() const;
  inline void clear_extract();
  static const int kExtractFieldNumber = 3;
  inline bool extract() const;
  inline void set_extract(bool value);

  // @@protoc_insertion_point(class_scope:mesos.CommandInfo.URI)
 private:
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_executable();
  inline void clear_has_executable();
  inline void set_has_extract();
  inline void clear_has_extract();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* value_;
  bool executable_;
  bool extract_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static CommandInfo_URI* default_instance_;
};
// -------------------------------------------------------------------

class CommandInfo_ContainerInfo : public ::google::protobuf::Message {
 public:
  CommandInfo_ContainerInfo();
  virtual ~CommandInfo_ContainerInfo();

  CommandInfo_ContainerInfo(const CommandInfo_ContainerInfo& from);

  inline CommandInfo_ContainerInfo& operator=(const CommandInfo_ContainerInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandInfo_ContainerInfo& default_instance();

  void Swap(CommandInfo_ContainerInfo* other);

  // implements Message ----------------------------------------------

  CommandInfo_ContainerInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandInfo_ContainerInfo& from);
  void MergeFrom(const CommandInfo_ContainerInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string image = 1;
  inline bool has_image() const;
  inline void clear_image();
  static const int kImageFieldNumber = 1;
  inline const ::std::string& image() const;
  inline void set_image(const ::std::string& value);
  inline void set_image(const char* value);
  inline void set_image(const char* value, size_t size);
  inline ::std::string* mutable_image();
  inline ::std::string* release_image();
  inline void set_allocated_image(::std::string* image);

  // repeated string options = 2;
  inline int options_size() const;
  inline void clear_options();
  static const int kOptionsFieldNumber = 2;
  inline const ::std::string& options(int index) const;
  inline ::std::string* mutable_options(int index);
  inline void set_options(int index, const ::std::string& value);
  inline void set_options(int index, const char* value);
  inline void set_options(int index, const char* value, size_t size);
  inline ::std::string* add_options();
  inline void add_options(const ::std::string& value);
  inline void add_options(const char* value);
  inline void add_options(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& options() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_options();

  // @@protoc_insertion_point(class_scope:mesos.CommandInfo.ContainerInfo)
 private:
  inline void set_has_image();
  inline void clear_has_image();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* image_;
  ::google::protobuf::RepeatedPtrField< ::std::string> options_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static CommandInfo_ContainerInfo* default_instance_;
};
// -------------------------------------------------------------------

class CommandInfo : public ::google::protobuf::Message {
 public:
  CommandInfo();
  virtual ~CommandInfo();

  CommandInfo(const CommandInfo& from);

  inline CommandInfo& operator=(const CommandInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandInfo& default_instance();

  void Swap(CommandInfo* other);

  // implements Message ----------------------------------------------

  CommandInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandInfo& from);
  void MergeFrom(const CommandInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CommandInfo_URI URI;
  typedef CommandInfo_ContainerInfo ContainerInfo;

  // accessors -------------------------------------------------------

  // optional .mesos.CommandInfo.ContainerInfo container = 4;
  inline bool has_container() const;
  inline void clear_container();
  static const int kContainerFieldNumber = 4;
  inline const ::mesos::CommandInfo_ContainerInfo& container() const;
  inline ::mesos::CommandInfo_ContainerInfo* mutable_container();
  inline ::mesos::CommandInfo_ContainerInfo* release_container();
  inline void set_allocated_container(::mesos::CommandInfo_ContainerInfo* container);

  // repeated .mesos.CommandInfo.URI uris = 1;
  inline int uris_size() const;
  inline void clear_uris();
  static const int kUrisFieldNumber = 1;
  inline const ::mesos::CommandInfo_URI& uris(int index) const;
  inline ::mesos::CommandInfo_URI* mutable_uris(int index);
  inline ::mesos::CommandInfo_URI* add_uris();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::CommandInfo_URI >&
      uris() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::CommandInfo_URI >*
      mutable_uris();

  // optional .mesos.Environment environment = 2;
  inline bool has_environment() const;
  inline void clear_environment();
  static const int kEnvironmentFieldNumber = 2;
  inline const ::mesos::Environment& environment() const;
  inline ::mesos::Environment* mutable_environment();
  inline ::mesos::Environment* release_environment();
  inline void set_allocated_environment(::mesos::Environment* environment);

  // required string value = 3;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 3;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // optional string user = 5;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 5;
  inline const ::std::string& user() const;
  inline void set_user(const ::std::string& value);
  inline void set_user(const char* value);
  inline void set_user(const char* value, size_t size);
  inline ::std::string* mutable_user();
  inline ::std::string* release_user();
  inline void set_allocated_user(::std::string* user);

  // optional .mesos.HealthCheck health_check = 6;
  inline bool has_health_check() const;
  inline void clear_health_check();
  static const int kHealthCheckFieldNumber = 6;
  inline const ::mesos::HealthCheck& health_check() const;
  inline ::mesos::HealthCheck* mutable_health_check();
  inline ::mesos::HealthCheck* release_health_check();
  inline void set_allocated_health_check(::mesos::HealthCheck* health_check);

  // @@protoc_insertion_point(class_scope:mesos.CommandInfo)
 private:
  inline void set_has_container();
  inline void clear_has_container();
  inline void set_has_environment();
  inline void clear_has_environment();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_health_check();
  inline void clear_has_health_check();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::CommandInfo_ContainerInfo* container_;
  ::google::protobuf::RepeatedPtrField< ::mesos::CommandInfo_URI > uris_;
  ::mesos::Environment* environment_;
  ::std::string* value_;
  ::std::string* user_;
  ::mesos::HealthCheck* health_check_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static CommandInfo* default_instance_;
};
// -------------------------------------------------------------------

class ExecutorInfo : public ::google::protobuf::Message {
 public:
  ExecutorInfo();
  virtual ~ExecutorInfo();

  ExecutorInfo(const ExecutorInfo& from);

  inline ExecutorInfo& operator=(const ExecutorInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExecutorInfo& default_instance();

  void Swap(ExecutorInfo* other);

  // implements Message ----------------------------------------------

  ExecutorInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExecutorInfo& from);
  void MergeFrom(const ExecutorInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ExecutorID executor_id = 1;
  inline bool has_executor_id() const;
  inline void clear_executor_id();
  static const int kExecutorIdFieldNumber = 1;
  inline const ::mesos::ExecutorID& executor_id() const;
  inline ::mesos::ExecutorID* mutable_executor_id();
  inline ::mesos::ExecutorID* release_executor_id();
  inline void set_allocated_executor_id(::mesos::ExecutorID* executor_id);

  // optional .mesos.FrameworkID framework_id = 8;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 8;
  inline const ::mesos::FrameworkID& framework_id() const;
  inline ::mesos::FrameworkID* mutable_framework_id();
  inline ::mesos::FrameworkID* release_framework_id();
  inline void set_allocated_framework_id(::mesos::FrameworkID* framework_id);

  // required .mesos.CommandInfo command = 7;
  inline bool has_command() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 7;
  inline const ::mesos::CommandInfo& command() const;
  inline ::mesos::CommandInfo* mutable_command();
  inline ::mesos::CommandInfo* release_command();
  inline void set_allocated_command(::mesos::CommandInfo* command);

  // repeated .mesos.Resource resources = 5;
  inline int resources_size() const;
  inline void clear_resources();
  static const int kResourcesFieldNumber = 5;
  inline const ::mesos::Resource& resources(int index) const;
  inline ::mesos::Resource* mutable_resources(int index);
  inline ::mesos::Resource* add_resources();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      resources() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_resources();

  // optional string name = 9;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 9;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string source = 10;
  inline bool has_source() const;
  inline void clear_source();
  static const int kSourceFieldNumber = 10;
  inline const ::std::string& source() const;
  inline void set_source(const ::std::string& value);
  inline void set_source(const char* value);
  inline void set_source(const char* value, size_t size);
  inline ::std::string* mutable_source();
  inline ::std::string* release_source();
  inline void set_allocated_source(::std::string* source);

  // optional bytes data = 4;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 4;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:mesos.ExecutorInfo)
 private:
  inline void set_has_executor_id();
  inline void clear_has_executor_id();
  inline void set_has_framework_id();
  inline void clear_has_framework_id();
  inline void set_has_command();
  inline void clear_has_command();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_source();
  inline void clear_has_source();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::ExecutorID* executor_id_;
  ::mesos::FrameworkID* framework_id_;
  ::mesos::CommandInfo* command_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > resources_;
  ::std::string* name_;
  ::std::string* source_;
  ::std::string* data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static ExecutorInfo* default_instance_;
};
// -------------------------------------------------------------------

class MasterInfo : public ::google::protobuf::Message {
 public:
  MasterInfo();
  virtual ~MasterInfo();

  MasterInfo(const MasterInfo& from);

  inline MasterInfo& operator=(const MasterInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MasterInfo& default_instance();

  void Swap(MasterInfo* other);

  // implements Message ----------------------------------------------

  MasterInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MasterInfo& from);
  void MergeFrom(const MasterInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required uint32 ip = 2;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 2;
  inline ::google::protobuf::uint32 ip() const;
  inline void set_ip(::google::protobuf::uint32 value);

  // required uint32 port = 3 [default = 5050];
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // optional string pid = 4;
  inline bool has_pid() const;
  inline void clear_pid();
  static const int kPidFieldNumber = 4;
  inline const ::std::string& pid() const;
  inline void set_pid(const ::std::string& value);
  inline void set_pid(const char* value);
  inline void set_pid(const char* value, size_t size);
  inline ::std::string* mutable_pid();
  inline ::std::string* release_pid();
  inline void set_allocated_pid(::std::string* pid);

  // optional string hostname = 5;
  inline bool has_hostname() const;
  inline void clear_hostname();
  static const int kHostnameFieldNumber = 5;
  inline const ::std::string& hostname() const;
  inline void set_hostname(const ::std::string& value);
  inline void set_hostname(const char* value);
  inline void set_hostname(const char* value, size_t size);
  inline ::std::string* mutable_hostname();
  inline ::std::string* release_hostname();
  inline void set_allocated_hostname(::std::string* hostname);

  // @@protoc_insertion_point(class_scope:mesos.MasterInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_pid();
  inline void clear_has_pid();
  inline void set_has_hostname();
  inline void clear_has_hostname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::google::protobuf::uint32 ip_;
  ::google::protobuf::uint32 port_;
  ::std::string* pid_;
  ::std::string* hostname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static MasterInfo* default_instance_;
};
// -------------------------------------------------------------------

class SlaveInfo : public ::google::protobuf::Message {
 public:
  SlaveInfo();
  virtual ~SlaveInfo();

  SlaveInfo(const SlaveInfo& from);

  inline SlaveInfo& operator=(const SlaveInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SlaveInfo& default_instance();

  void Swap(SlaveInfo* other);

  // implements Message ----------------------------------------------

  SlaveInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SlaveInfo& from);
  void MergeFrom(const SlaveInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string hostname = 1;
  inline bool has_hostname() const;
  inline void clear_hostname();
  static const int kHostnameFieldNumber = 1;
  inline const ::std::string& hostname() const;
  inline void set_hostname(const ::std::string& value);
  inline void set_hostname(const char* value);
  inline void set_hostname(const char* value, size_t size);
  inline ::std::string* mutable_hostname();
  inline ::std::string* release_hostname();
  inline void set_allocated_hostname(::std::string* hostname);

  // optional int32 port = 8 [default = 5051];
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 8;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);

  // repeated .mesos.Resource resources = 3;
  inline int resources_size() const;
  inline void clear_resources();
  static const int kResourcesFieldNumber = 3;
  inline const ::mesos::Resource& resources(int index) const;
  inline ::mesos::Resource* mutable_resources(int index);
  inline ::mesos::Resource* add_resources();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      resources() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_resources();

  // repeated .mesos.Attribute attributes = 5;
  inline int attributes_size() const;
  inline void clear_attributes();
  static const int kAttributesFieldNumber = 5;
  inline const ::mesos::Attribute& attributes(int index) const;
  inline ::mesos::Attribute* mutable_attributes(int index);
  inline ::mesos::Attribute* add_attributes();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Attribute >&
      attributes() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Attribute >*
      mutable_attributes();

  // optional .mesos.SlaveID id = 6;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 6;
  inline const ::mesos::SlaveID& id() const;
  inline ::mesos::SlaveID* mutable_id();
  inline ::mesos::SlaveID* release_id();
  inline void set_allocated_id(::mesos::SlaveID* id);

  // optional bool checkpoint = 7 [default = false];
  inline bool has_checkpoint() const;
  inline void clear_checkpoint();
  static const int kCheckpointFieldNumber = 7;
  inline bool checkpoint() const;
  inline void set_checkpoint(bool value);

  // optional string webui_hostname = 2;
  inline bool has_webui_hostname() const;
  inline void clear_webui_hostname();
  static const int kWebuiHostnameFieldNumber = 2;
  inline const ::std::string& webui_hostname() const;
  inline void set_webui_hostname(const ::std::string& value);
  inline void set_webui_hostname(const char* value);
  inline void set_webui_hostname(const char* value, size_t size);
  inline ::std::string* mutable_webui_hostname();
  inline ::std::string* release_webui_hostname();
  inline void set_allocated_webui_hostname(::std::string* webui_hostname);

  // optional int32 webui_port = 4 [default = 8081];
  inline bool has_webui_port() const;
  inline void clear_webui_port();
  static const int kWebuiPortFieldNumber = 4;
  inline ::google::protobuf::int32 webui_port() const;
  inline void set_webui_port(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mesos.SlaveInfo)
 private:
  inline void set_has_hostname();
  inline void clear_has_hostname();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_checkpoint();
  inline void clear_has_checkpoint();
  inline void set_has_webui_hostname();
  inline void clear_has_webui_hostname();
  inline void set_has_webui_port();
  inline void clear_has_webui_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* hostname_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > resources_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Attribute > attributes_;
  ::google::protobuf::int32 port_;
  bool checkpoint_;
  ::mesos::SlaveID* id_;
  ::std::string* webui_hostname_;
  ::google::protobuf::int32 webui_port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static SlaveInfo* default_instance_;
};
// -------------------------------------------------------------------

class Value_Scalar : public ::google::protobuf::Message {
 public:
  Value_Scalar();
  virtual ~Value_Scalar();

  Value_Scalar(const Value_Scalar& from);

  inline Value_Scalar& operator=(const Value_Scalar& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Value_Scalar& default_instance();

  void Swap(Value_Scalar* other);

  // implements Message ----------------------------------------------

  Value_Scalar* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Value_Scalar& from);
  void MergeFrom(const Value_Scalar& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline double value() const;
  inline void set_value(double value);

  // @@protoc_insertion_point(class_scope:mesos.Value.Scalar)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static Value_Scalar* default_instance_;
};
// -------------------------------------------------------------------

class Value_Range : public ::google::protobuf::Message {
 public:
  Value_Range();
  virtual ~Value_Range();

  Value_Range(const Value_Range& from);

  inline Value_Range& operator=(const Value_Range& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Value_Range& default_instance();

  void Swap(Value_Range* other);

  // implements Message ----------------------------------------------

  Value_Range* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Value_Range& from);
  void MergeFrom(const Value_Range& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 begin = 1;
  inline bool has_begin() const;
  inline void clear_begin();
  static const int kBeginFieldNumber = 1;
  inline ::google::protobuf::uint64 begin() const;
  inline void set_begin(::google::protobuf::uint64 value);

  // required uint64 end = 2;
  inline bool has_end() const;
  inline void clear_end();
  static const int kEndFieldNumber = 2;
  inline ::google::protobuf::uint64 end() const;
  inline void set_end(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mesos.Value.Range)
 private:
  inline void set_has_begin();
  inline void clear_has_begin();
  inline void set_has_end();
  inline void clear_has_end();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 begin_;
  ::google::protobuf::uint64 end_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static Value_Range* default_instance_;
};
// -------------------------------------------------------------------

class Value_Ranges : public ::google::protobuf::Message {
 public:
  Value_Ranges();
  virtual ~Value_Ranges();

  Value_Ranges(const Value_Ranges& from);

  inline Value_Ranges& operator=(const Value_Ranges& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Value_Ranges& default_instance();

  void Swap(Value_Ranges* other);

  // implements Message ----------------------------------------------

  Value_Ranges* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Value_Ranges& from);
  void MergeFrom(const Value_Ranges& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.Value.Range range = 1;
  inline int range_size() const;
  inline void clear_range();
  static const int kRangeFieldNumber = 1;
  inline const ::mesos::Value_Range& range(int index) const;
  inline ::mesos::Value_Range* mutable_range(int index);
  inline ::mesos::Value_Range* add_range();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Value_Range >&
      range() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Value_Range >*
      mutable_range();

  // @@protoc_insertion_point(class_scope:mesos.Value.Ranges)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mesos::Value_Range > range_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static Value_Ranges* default_instance_;
};
// -------------------------------------------------------------------

class Value_Set : public ::google::protobuf::Message {
 public:
  Value_Set();
  virtual ~Value_Set();

  Value_Set(const Value_Set& from);

  inline Value_Set& operator=(const Value_Set& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Value_Set& default_instance();

  void Swap(Value_Set* other);

  // implements Message ----------------------------------------------

  Value_Set* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Value_Set& from);
  void MergeFrom(const Value_Set& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string item = 1;
  inline int item_size() const;
  inline void clear_item();
  static const int kItemFieldNumber = 1;
  inline const ::std::string& item(int index) const;
  inline ::std::string* mutable_item(int index);
  inline void set_item(int index, const ::std::string& value);
  inline void set_item(int index, const char* value);
  inline void set_item(int index, const char* value, size_t size);
  inline ::std::string* add_item();
  inline void add_item(const ::std::string& value);
  inline void add_item(const char* value);
  inline void add_item(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& item() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_item();

  // @@protoc_insertion_point(class_scope:mesos.Value.Set)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> item_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static Value_Set* default_instance_;
};
// -------------------------------------------------------------------

class Value_Text : public ::google::protobuf::Message {
 public:
  Value_Text();
  virtual ~Value_Text();

  Value_Text(const Value_Text& from);

  inline Value_Text& operator=(const Value_Text& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Value_Text& default_instance();

  void Swap(Value_Text* other);

  // implements Message ----------------------------------------------

  Value_Text* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Value_Text& from);
  void MergeFrom(const Value_Text& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:mesos.Value.Text)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static Value_Text* default_instance_;
};
// -------------------------------------------------------------------

class Value : public ::google::protobuf::Message {
 public:
  Value();
  virtual ~Value();

  Value(const Value& from);

  inline Value& operator=(const Value& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Value& default_instance();

  void Swap(Value* other);

  // implements Message ----------------------------------------------

  Value* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Value& from);
  void MergeFrom(const Value& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Value_Scalar Scalar;
  typedef Value_Range Range;
  typedef Value_Ranges Ranges;
  typedef Value_Set Set;
  typedef Value_Text Text;

  typedef Value_Type Type;
  static const Type SCALAR = Value_Type_SCALAR;
  static const Type RANGES = Value_Type_RANGES;
  static const Type SET = Value_Type_SET;
  static const Type TEXT = Value_Type_TEXT;
  static inline bool Type_IsValid(int value) {
    return Value_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Value_Type_Type_MIN;
  static const Type Type_MAX =
    Value_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Value_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Value_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Value_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Value_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .mesos.Value.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::mesos::Value_Type type() const;
  inline void set_type(::mesos::Value_Type value);

  // optional .mesos.Value.Scalar scalar = 2;
  inline bool has_scalar() const;
  inline void clear_scalar();
  static const int kScalarFieldNumber = 2;
  inline const ::mesos::Value_Scalar& scalar() const;
  inline ::mesos::Value_Scalar* mutable_scalar();
  inline ::mesos::Value_Scalar* release_scalar();
  inline void set_allocated_scalar(::mesos::Value_Scalar* scalar);

  // optional .mesos.Value.Ranges ranges = 3;
  inline bool has_ranges() const;
  inline void clear_ranges();
  static const int kRangesFieldNumber = 3;
  inline const ::mesos::Value_Ranges& ranges() const;
  inline ::mesos::Value_Ranges* mutable_ranges();
  inline ::mesos::Value_Ranges* release_ranges();
  inline void set_allocated_ranges(::mesos::Value_Ranges* ranges);

  // optional .mesos.Value.Set set = 4;
  inline bool has_set() const;
  inline void clear_set();
  static const int kSetFieldNumber = 4;
  inline const ::mesos::Value_Set& set() const;
  inline ::mesos::Value_Set* mutable_set();
  inline ::mesos::Value_Set* release_set();
  inline void set_allocated_set(::mesos::Value_Set* set);

  // optional .mesos.Value.Text text = 5;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 5;
  inline const ::mesos::Value_Text& text() const;
  inline ::mesos::Value_Text* mutable_text();
  inline ::mesos::Value_Text* release_text();
  inline void set_allocated_text(::mesos::Value_Text* text);

  // @@protoc_insertion_point(class_scope:mesos.Value)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_scalar();
  inline void clear_has_scalar();
  inline void set_has_ranges();
  inline void clear_has_ranges();
  inline void set_has_set();
  inline void clear_has_set();
  inline void set_has_text();
  inline void clear_has_text();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::Value_Scalar* scalar_;
  ::mesos::Value_Ranges* ranges_;
  ::mesos::Value_Set* set_;
  ::mesos::Value_Text* text_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static Value* default_instance_;
};
// -------------------------------------------------------------------

class Attribute : public ::google::protobuf::Message {
 public:
  Attribute();
  virtual ~Attribute();

  Attribute(const Attribute& from);

  inline Attribute& operator=(const Attribute& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Attribute& default_instance();

  void Swap(Attribute* other);

  // implements Message ----------------------------------------------

  Attribute* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Attribute& from);
  void MergeFrom(const Attribute& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required .mesos.Value.Type type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::mesos::Value_Type type() const;
  inline void set_type(::mesos::Value_Type value);

  // optional .mesos.Value.Scalar scalar = 3;
  inline bool has_scalar() const;
  inline void clear_scalar();
  static const int kScalarFieldNumber = 3;
  inline const ::mesos::Value_Scalar& scalar() const;
  inline ::mesos::Value_Scalar* mutable_scalar();
  inline ::mesos::Value_Scalar* release_scalar();
  inline void set_allocated_scalar(::mesos::Value_Scalar* scalar);

  // optional .mesos.Value.Ranges ranges = 4;
  inline bool has_ranges() const;
  inline void clear_ranges();
  static const int kRangesFieldNumber = 4;
  inline const ::mesos::Value_Ranges& ranges() const;
  inline ::mesos::Value_Ranges* mutable_ranges();
  inline ::mesos::Value_Ranges* release_ranges();
  inline void set_allocated_ranges(::mesos::Value_Ranges* ranges);

  // optional .mesos.Value.Set set = 6;
  inline bool has_set() const;
  inline void clear_set();
  static const int kSetFieldNumber = 6;
  inline const ::mesos::Value_Set& set() const;
  inline ::mesos::Value_Set* mutable_set();
  inline ::mesos::Value_Set* release_set();
  inline void set_allocated_set(::mesos::Value_Set* set);

  // optional .mesos.Value.Text text = 5;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 5;
  inline const ::mesos::Value_Text& text() const;
  inline ::mesos::Value_Text* mutable_text();
  inline ::mesos::Value_Text* release_text();
  inline void set_allocated_text(::mesos::Value_Text* text);

  // @@protoc_insertion_point(class_scope:mesos.Attribute)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_scalar();
  inline void clear_has_scalar();
  inline void set_has_ranges();
  inline void clear_has_ranges();
  inline void set_has_set();
  inline void clear_has_set();
  inline void set_has_text();
  inline void clear_has_text();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::mesos::Value_Scalar* scalar_;
  ::mesos::Value_Ranges* ranges_;
  ::mesos::Value_Set* set_;
  ::mesos::Value_Text* text_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static Attribute* default_instance_;
};
// -------------------------------------------------------------------

class Resource : public ::google::protobuf::Message {
 public:
  Resource();
  virtual ~Resource();

  Resource(const Resource& from);

  inline Resource& operator=(const Resource& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Resource& default_instance();

  void Swap(Resource* other);

  // implements Message ----------------------------------------------

  Resource* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Resource& from);
  void MergeFrom(const Resource& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required .mesos.Value.Type type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::mesos::Value_Type type() const;
  inline void set_type(::mesos::Value_Type value);

  // optional .mesos.Value.Scalar scalar = 3;
  inline bool has_scalar() const;
  inline void clear_scalar();
  static const int kScalarFieldNumber = 3;
  inline const ::mesos::Value_Scalar& scalar() const;
  inline ::mesos::Value_Scalar* mutable_scalar();
  inline ::mesos::Value_Scalar* release_scalar();
  inline void set_allocated_scalar(::mesos::Value_Scalar* scalar);

  // optional .mesos.Value.Ranges ranges = 4;
  inline bool has_ranges() const;
  inline void clear_ranges();
  static const int kRangesFieldNumber = 4;
  inline const ::mesos::Value_Ranges& ranges() const;
  inline ::mesos::Value_Ranges* mutable_ranges();
  inline ::mesos::Value_Ranges* release_ranges();
  inline void set_allocated_ranges(::mesos::Value_Ranges* ranges);

  // optional .mesos.Value.Set set = 5;
  inline bool has_set() const;
  inline void clear_set();
  static const int kSetFieldNumber = 5;
  inline const ::mesos::Value_Set& set() const;
  inline ::mesos::Value_Set* mutable_set();
  inline ::mesos::Value_Set* release_set();
  inline void set_allocated_set(::mesos::Value_Set* set);

  // optional string role = 6 [default = "*"];
  inline bool has_role() const;
  inline void clear_role();
  static const int kRoleFieldNumber = 6;
  inline const ::std::string& role() const;
  inline void set_role(const ::std::string& value);
  inline void set_role(const char* value);
  inline void set_role(const char* value, size_t size);
  inline ::std::string* mutable_role();
  inline ::std::string* release_role();
  inline void set_allocated_role(::std::string* role);

  // @@protoc_insertion_point(class_scope:mesos.Resource)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_scalar();
  inline void clear_has_scalar();
  inline void set_has_ranges();
  inline void clear_has_ranges();
  inline void set_has_set();
  inline void clear_has_set();
  inline void set_has_role();
  inline void clear_has_role();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::mesos::Value_Scalar* scalar_;
  ::mesos::Value_Ranges* ranges_;
  ::mesos::Value_Set* set_;
  ::std::string* role_;
  static ::std::string* _default_role_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static Resource* default_instance_;
};
// -------------------------------------------------------------------

class ResourceStatistics : public ::google::protobuf::Message {
 public:
  ResourceStatistics();
  virtual ~ResourceStatistics();

  ResourceStatistics(const ResourceStatistics& from);

  inline ResourceStatistics& operator=(const ResourceStatistics& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResourceStatistics& default_instance();

  void Swap(ResourceStatistics* other);

  // implements Message ----------------------------------------------

  ResourceStatistics* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResourceStatistics& from);
  void MergeFrom(const ResourceStatistics& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double timestamp = 1;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  inline double timestamp() const;
  inline void set_timestamp(double value);

  // optional double cpus_user_time_secs = 2;
  inline bool has_cpus_user_time_secs() const;
  inline void clear_cpus_user_time_secs();
  static const int kCpusUserTimeSecsFieldNumber = 2;
  inline double cpus_user_time_secs() const;
  inline void set_cpus_user_time_secs(double value);

  // optional double cpus_system_time_secs = 3;
  inline bool has_cpus_system_time_secs() const;
  inline void clear_cpus_system_time_secs();
  static const int kCpusSystemTimeSecsFieldNumber = 3;
  inline double cpus_system_time_secs() const;
  inline void set_cpus_system_time_secs(double value);

  // optional double cpus_limit = 4;
  inline bool has_cpus_limit() const;
  inline void clear_cpus_limit();
  static const int kCpusLimitFieldNumber = 4;
  inline double cpus_limit() const;
  inline void set_cpus_limit(double value);

  // optional uint32 cpus_nr_periods = 7;
  inline bool has_cpus_nr_periods() const;
  inline void clear_cpus_nr_periods();
  static const int kCpusNrPeriodsFieldNumber = 7;
  inline ::google::protobuf::uint32 cpus_nr_periods() const;
  inline void set_cpus_nr_periods(::google::protobuf::uint32 value);

  // optional uint32 cpus_nr_throttled = 8;
  inline bool has_cpus_nr_throttled() const;
  inline void clear_cpus_nr_throttled();
  static const int kCpusNrThrottledFieldNumber = 8;
  inline ::google::protobuf::uint32 cpus_nr_throttled() const;
  inline void set_cpus_nr_throttled(::google::protobuf::uint32 value);

  // optional double cpus_throttled_time_secs = 9;
  inline bool has_cpus_throttled_time_secs() const;
  inline void clear_cpus_throttled_time_secs();
  static const int kCpusThrottledTimeSecsFieldNumber = 9;
  inline double cpus_throttled_time_secs() const;
  inline void set_cpus_throttled_time_secs(double value);

  // optional uint64 mem_rss_bytes = 5;
  inline bool has_mem_rss_bytes() const;
  inline void clear_mem_rss_bytes();
  static const int kMemRssBytesFieldNumber = 5;
  inline ::google::protobuf::uint64 mem_rss_bytes() const;
  inline void set_mem_rss_bytes(::google::protobuf::uint64 value);

  // optional uint64 mem_limit_bytes = 6;
  inline bool has_mem_limit_bytes() const;
  inline void clear_mem_limit_bytes();
  static const int kMemLimitBytesFieldNumber = 6;
  inline ::google::protobuf::uint64 mem_limit_bytes() const;
  inline void set_mem_limit_bytes(::google::protobuf::uint64 value);

  // optional uint64 mem_file_bytes = 10;
  inline bool has_mem_file_bytes() const;
  inline void clear_mem_file_bytes();
  static const int kMemFileBytesFieldNumber = 10;
  inline ::google::protobuf::uint64 mem_file_bytes() const;
  inline void set_mem_file_bytes(::google::protobuf::uint64 value);

  // optional uint64 mem_anon_bytes = 11;
  inline bool has_mem_anon_bytes() const;
  inline void clear_mem_anon_bytes();
  static const int kMemAnonBytesFieldNumber = 11;
  inline ::google::protobuf::uint64 mem_anon_bytes() const;
  inline void set_mem_anon_bytes(::google::protobuf::uint64 value);

  // optional uint64 mem_mapped_file_bytes = 12;
  inline bool has_mem_mapped_file_bytes() const;
  inline void clear_mem_mapped_file_bytes();
  static const int kMemMappedFileBytesFieldNumber = 12;
  inline ::google::protobuf::uint64 mem_mapped_file_bytes() const;
  inline void set_mem_mapped_file_bytes(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mesos.ResourceStatistics)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_cpus_user_time_secs();
  inline void clear_has_cpus_user_time_secs();
  inline void set_has_cpus_system_time_secs();
  inline void clear_has_cpus_system_time_secs();
  inline void set_has_cpus_limit();
  inline void clear_has_cpus_limit();
  inline void set_has_cpus_nr_periods();
  inline void clear_has_cpus_nr_periods();
  inline void set_has_cpus_nr_throttled();
  inline void clear_has_cpus_nr_throttled();
  inline void set_has_cpus_throttled_time_secs();
  inline void clear_has_cpus_throttled_time_secs();
  inline void set_has_mem_rss_bytes();
  inline void clear_has_mem_rss_bytes();
  inline void set_has_mem_limit_bytes();
  inline void clear_has_mem_limit_bytes();
  inline void set_has_mem_file_bytes();
  inline void clear_has_mem_file_bytes();
  inline void set_has_mem_anon_bytes();
  inline void clear_has_mem_anon_bytes();
  inline void set_has_mem_mapped_file_bytes();
  inline void clear_has_mem_mapped_file_bytes();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double timestamp_;
  double cpus_user_time_secs_;
  double cpus_system_time_secs_;
  double cpus_limit_;
  ::google::protobuf::uint32 cpus_nr_periods_;
  ::google::protobuf::uint32 cpus_nr_throttled_;
  double cpus_throttled_time_secs_;
  ::google::protobuf::uint64 mem_rss_bytes_;
  ::google::protobuf::uint64 mem_limit_bytes_;
  ::google::protobuf::uint64 mem_file_bytes_;
  ::google::protobuf::uint64 mem_anon_bytes_;
  ::google::protobuf::uint64 mem_mapped_file_bytes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static ResourceStatistics* default_instance_;
};
// -------------------------------------------------------------------

class ResourceUsage : public ::google::protobuf::Message {
 public:
  ResourceUsage();
  virtual ~ResourceUsage();

  ResourceUsage(const ResourceUsage& from);

  inline ResourceUsage& operator=(const ResourceUsage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResourceUsage& default_instance();

  void Swap(ResourceUsage* other);

  // implements Message ----------------------------------------------

  ResourceUsage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResourceUsage& from);
  void MergeFrom(const ResourceUsage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.SlaveID slave_id = 1;
  inline bool has_slave_id() const;
  inline void clear_slave_id();
  static const int kSlaveIdFieldNumber = 1;
  inline const ::mesos::SlaveID& slave_id() const;
  inline ::mesos::SlaveID* mutable_slave_id();
  inline ::mesos::SlaveID* release_slave_id();
  inline void set_allocated_slave_id(::mesos::SlaveID* slave_id);

  // required .mesos.FrameworkID framework_id = 2;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 2;
  inline const ::mesos::FrameworkID& framework_id() const;
  inline ::mesos::FrameworkID* mutable_framework_id();
  inline ::mesos::FrameworkID* release_framework_id();
  inline void set_allocated_framework_id(::mesos::FrameworkID* framework_id);

  // optional .mesos.ExecutorID executor_id = 3;
  inline bool has_executor_id() const;
  inline void clear_executor_id();
  static const int kExecutorIdFieldNumber = 3;
  inline const ::mesos::ExecutorID& executor_id() const;
  inline ::mesos::ExecutorID* mutable_executor_id();
  inline ::mesos::ExecutorID* release_executor_id();
  inline void set_allocated_executor_id(::mesos::ExecutorID* executor_id);

  // optional string executor_name = 4;
  inline bool has_executor_name() const;
  inline void clear_executor_name();
  static const int kExecutorNameFieldNumber = 4;
  inline const ::std::string& executor_name() const;
  inline void set_executor_name(const ::std::string& value);
  inline void set_executor_name(const char* value);
  inline void set_executor_name(const char* value, size_t size);
  inline ::std::string* mutable_executor_name();
  inline ::std::string* release_executor_name();
  inline void set_allocated_executor_name(::std::string* executor_name);

  // optional .mesos.TaskID task_id = 5;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 5;
  inline const ::mesos::TaskID& task_id() const;
  inline ::mesos::TaskID* mutable_task_id();
  inline ::mesos::TaskID* release_task_id();
  inline void set_allocated_task_id(::mesos::TaskID* task_id);

  // optional .mesos.ResourceStatistics statistics = 6;
  inline bool has_statistics() const;
  inline void clear_statistics();
  static const int kStatisticsFieldNumber = 6;
  inline const ::mesos::ResourceStatistics& statistics() const;
  inline ::mesos::ResourceStatistics* mutable_statistics();
  inline ::mesos::ResourceStatistics* release_statistics();
  inline void set_allocated_statistics(::mesos::ResourceStatistics* statistics);

  // @@protoc_insertion_point(class_scope:mesos.ResourceUsage)
 private:
  inline void set_has_slave_id();
  inline void clear_has_slave_id();
  inline void set_has_framework_id();
  inline void clear_has_framework_id();
  inline void set_has_executor_id();
  inline void clear_has_executor_id();
  inline void set_has_executor_name();
  inline void clear_has_executor_name();
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_statistics();
  inline void clear_has_statistics();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::SlaveID* slave_id_;
  ::mesos::FrameworkID* framework_id_;
  ::mesos::ExecutorID* executor_id_;
  ::std::string* executor_name_;
  ::mesos::TaskID* task_id_;
  ::mesos::ResourceStatistics* statistics_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static ResourceUsage* default_instance_;
};
// -------------------------------------------------------------------

class Request : public ::google::protobuf::Message {
 public:
  Request();
  virtual ~Request();

  Request(const Request& from);

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request& default_instance();

  void Swap(Request* other);

  // implements Message ----------------------------------------------

  Request* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mesos.SlaveID slave_id = 1;
  inline bool has_slave_id() const;
  inline void clear_slave_id();
  static const int kSlaveIdFieldNumber = 1;
  inline const ::mesos::SlaveID& slave_id() const;
  inline ::mesos::SlaveID* mutable_slave_id();
  inline ::mesos::SlaveID* release_slave_id();
  inline void set_allocated_slave_id(::mesos::SlaveID* slave_id);

  // repeated .mesos.Resource resources = 2;
  inline int resources_size() const;
  inline void clear_resources();
  static const int kResourcesFieldNumber = 2;
  inline const ::mesos::Resource& resources(int index) const;
  inline ::mesos::Resource* mutable_resources(int index);
  inline ::mesos::Resource* add_resources();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      resources() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_resources();

  // @@protoc_insertion_point(class_scope:mesos.Request)
 private:
  inline void set_has_slave_id();
  inline void clear_has_slave_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::SlaveID* slave_id_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > resources_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static Request* default_instance_;
};
// -------------------------------------------------------------------

class Offer : public ::google::protobuf::Message {
 public:
  Offer();
  virtual ~Offer();

  Offer(const Offer& from);

  inline Offer& operator=(const Offer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Offer& default_instance();

  void Swap(Offer* other);

  // implements Message ----------------------------------------------

  Offer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Offer& from);
  void MergeFrom(const Offer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.OfferID id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::mesos::OfferID& id() const;
  inline ::mesos::OfferID* mutable_id();
  inline ::mesos::OfferID* release_id();
  inline void set_allocated_id(::mesos::OfferID* id);

  // required .mesos.FrameworkID framework_id = 2;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 2;
  inline const ::mesos::FrameworkID& framework_id() const;
  inline ::mesos::FrameworkID* mutable_framework_id();
  inline ::mesos::FrameworkID* release_framework_id();
  inline void set_allocated_framework_id(::mesos::FrameworkID* framework_id);

  // required .mesos.SlaveID slave_id = 3;
  inline bool has_slave_id() const;
  inline void clear_slave_id();
  static const int kSlaveIdFieldNumber = 3;
  inline const ::mesos::SlaveID& slave_id() const;
  inline ::mesos::SlaveID* mutable_slave_id();
  inline ::mesos::SlaveID* release_slave_id();
  inline void set_allocated_slave_id(::mesos::SlaveID* slave_id);

  // required string hostname = 4;
  inline bool has_hostname() const;
  inline void clear_hostname();
  static const int kHostnameFieldNumber = 4;
  inline const ::std::string& hostname() const;
  inline void set_hostname(const ::std::string& value);
  inline void set_hostname(const char* value);
  inline void set_hostname(const char* value, size_t size);
  inline ::std::string* mutable_hostname();
  inline ::std::string* release_hostname();
  inline void set_allocated_hostname(::std::string* hostname);

  // repeated .mesos.Resource resources = 5;
  inline int resources_size() const;
  inline void clear_resources();
  static const int kResourcesFieldNumber = 5;
  inline const ::mesos::Resource& resources(int index) const;
  inline ::mesos::Resource* mutable_resources(int index);
  inline ::mesos::Resource* add_resources();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      resources() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_resources();

  // repeated .mesos.Attribute attributes = 7;
  inline int attributes_size() const;
  inline void clear_attributes();
  static const int kAttributesFieldNumber = 7;
  inline const ::mesos::Attribute& attributes(int index) const;
  inline ::mesos::Attribute* mutable_attributes(int index);
  inline ::mesos::Attribute* add_attributes();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Attribute >&
      attributes() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Attribute >*
      mutable_attributes();

  // repeated .mesos.ExecutorID executor_ids = 6;
  inline int executor_ids_size() const;
  inline void clear_executor_ids();
  static const int kExecutorIdsFieldNumber = 6;
  inline const ::mesos::ExecutorID& executor_ids(int index) const;
  inline ::mesos::ExecutorID* mutable_executor_ids(int index);
  inline ::mesos::ExecutorID* add_executor_ids();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::ExecutorID >&
      executor_ids() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::ExecutorID >*
      mutable_executor_ids();

  // @@protoc_insertion_point(class_scope:mesos.Offer)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_framework_id();
  inline void clear_has_framework_id();
  inline void set_has_slave_id();
  inline void clear_has_slave_id();
  inline void set_has_hostname();
  inline void clear_has_hostname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::OfferID* id_;
  ::mesos::FrameworkID* framework_id_;
  ::mesos::SlaveID* slave_id_;
  ::std::string* hostname_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > resources_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Attribute > attributes_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ExecutorID > executor_ids_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static Offer* default_instance_;
};
// -------------------------------------------------------------------

class TaskInfo : public ::google::protobuf::Message {
 public:
  TaskInfo();
  virtual ~TaskInfo();

  TaskInfo(const TaskInfo& from);

  inline TaskInfo& operator=(const TaskInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskInfo& default_instance();

  void Swap(TaskInfo* other);

  // implements Message ----------------------------------------------

  TaskInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TaskInfo& from);
  void MergeFrom(const TaskInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required .mesos.TaskID task_id = 2;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 2;
  inline const ::mesos::TaskID& task_id() const;
  inline ::mesos::TaskID* mutable_task_id();
  inline ::mesos::TaskID* release_task_id();
  inline void set_allocated_task_id(::mesos::TaskID* task_id);

  // required .mesos.SlaveID slave_id = 3;
  inline bool has_slave_id() const;
  inline void clear_slave_id();
  static const int kSlaveIdFieldNumber = 3;
  inline const ::mesos::SlaveID& slave_id() const;
  inline ::mesos::SlaveID* mutable_slave_id();
  inline ::mesos::SlaveID* release_slave_id();
  inline void set_allocated_slave_id(::mesos::SlaveID* slave_id);

  // repeated .mesos.Resource resources = 4;
  inline int resources_size() const;
  inline void clear_resources();
  static const int kResourcesFieldNumber = 4;
  inline const ::mesos::Resource& resources(int index) const;
  inline ::mesos::Resource* mutable_resources(int index);
  inline ::mesos::Resource* add_resources();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      resources() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_resources();

  // optional .mesos.ExecutorInfo executor = 5;
  inline bool has_executor() const;
  inline void clear_executor();
  static const int kExecutorFieldNumber = 5;
  inline const ::mesos::ExecutorInfo& executor() const;
  inline ::mesos::ExecutorInfo* mutable_executor();
  inline ::mesos::ExecutorInfo* release_executor();
  inline void set_allocated_executor(::mesos::ExecutorInfo* executor);

  // optional .mesos.CommandInfo command = 7;
  inline bool has_command() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 7;
  inline const ::mesos::CommandInfo& command() const;
  inline ::mesos::CommandInfo* mutable_command();
  inline ::mesos::CommandInfo* release_command();
  inline void set_allocated_command(::mesos::CommandInfo* command);

  // optional bytes data = 6;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 6;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:mesos.TaskInfo)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_slave_id();
  inline void clear_has_slave_id();
  inline void set_has_executor();
  inline void clear_has_executor();
  inline void set_has_command();
  inline void clear_has_command();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::mesos::TaskID* task_id_;
  ::mesos::SlaveID* slave_id_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > resources_;
  ::mesos::ExecutorInfo* executor_;
  ::mesos::CommandInfo* command_;
  ::std::string* data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static TaskInfo* default_instance_;
};
// -------------------------------------------------------------------

class TaskStatus : public ::google::protobuf::Message {
 public:
  TaskStatus();
  virtual ~TaskStatus();

  TaskStatus(const TaskStatus& from);

  inline TaskStatus& operator=(const TaskStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskStatus& default_instance();

  void Swap(TaskStatus* other);

  // implements Message ----------------------------------------------

  TaskStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TaskStatus& from);
  void MergeFrom(const TaskStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.TaskID task_id = 1;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 1;
  inline const ::mesos::TaskID& task_id() const;
  inline ::mesos::TaskID* mutable_task_id();
  inline ::mesos::TaskID* release_task_id();
  inline void set_allocated_task_id(::mesos::TaskID* task_id);

  // required .mesos.TaskState state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline ::mesos::TaskState state() const;
  inline void set_state(::mesos::TaskState value);

  // optional string message = 4;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 4;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // optional bytes data = 3;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // optional .mesos.SlaveID slave_id = 5;
  inline bool has_slave_id() const;
  inline void clear_slave_id();
  static const int kSlaveIdFieldNumber = 5;
  inline const ::mesos::SlaveID& slave_id() const;
  inline ::mesos::SlaveID* mutable_slave_id();
  inline ::mesos::SlaveID* release_slave_id();
  inline void set_allocated_slave_id(::mesos::SlaveID* slave_id);

  // optional double timestamp = 6;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 6;
  inline double timestamp() const;
  inline void set_timestamp(double value);

  // @@protoc_insertion_point(class_scope:mesos.TaskStatus)
 private:
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_slave_id();
  inline void clear_has_slave_id();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::TaskID* task_id_;
  ::std::string* message_;
  ::std::string* data_;
  ::mesos::SlaveID* slave_id_;
  double timestamp_;
  int state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static TaskStatus* default_instance_;
};
// -------------------------------------------------------------------

class Filters : public ::google::protobuf::Message {
 public:
  Filters();
  virtual ~Filters();

  Filters(const Filters& from);

  inline Filters& operator=(const Filters& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Filters& default_instance();

  void Swap(Filters* other);

  // implements Message ----------------------------------------------

  Filters* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Filters& from);
  void MergeFrom(const Filters& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double refuse_seconds = 1 [default = 5];
  inline bool has_refuse_seconds() const;
  inline void clear_refuse_seconds();
  static const int kRefuseSecondsFieldNumber = 1;
  inline double refuse_seconds() const;
  inline void set_refuse_seconds(double value);

  // @@protoc_insertion_point(class_scope:mesos.Filters)
 private:
  inline void set_has_refuse_seconds();
  inline void clear_has_refuse_seconds();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double refuse_seconds_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static Filters* default_instance_;
};
// -------------------------------------------------------------------

class Environment_Variable : public ::google::protobuf::Message {
 public:
  Environment_Variable();
  virtual ~Environment_Variable();

  Environment_Variable(const Environment_Variable& from);

  inline Environment_Variable& operator=(const Environment_Variable& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Environment_Variable& default_instance();

  void Swap(Environment_Variable* other);

  // implements Message ----------------------------------------------

  Environment_Variable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Environment_Variable& from);
  void MergeFrom(const Environment_Variable& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:mesos.Environment.Variable)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static Environment_Variable* default_instance_;
};
// -------------------------------------------------------------------

class Environment : public ::google::protobuf::Message {
 public:
  Environment();
  virtual ~Environment();

  Environment(const Environment& from);

  inline Environment& operator=(const Environment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Environment& default_instance();

  void Swap(Environment* other);

  // implements Message ----------------------------------------------

  Environment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Environment& from);
  void MergeFrom(const Environment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Environment_Variable Variable;

  // accessors -------------------------------------------------------

  // repeated .mesos.Environment.Variable variables = 1;
  inline int variables_size() const;
  inline void clear_variables();
  static const int kVariablesFieldNumber = 1;
  inline const ::mesos::Environment_Variable& variables(int index) const;
  inline ::mesos::Environment_Variable* mutable_variables(int index);
  inline ::mesos::Environment_Variable* add_variables();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Environment_Variable >&
      variables() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Environment_Variable >*
      mutable_variables();

  // @@protoc_insertion_point(class_scope:mesos.Environment)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mesos::Environment_Variable > variables_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static Environment* default_instance_;
};
// -------------------------------------------------------------------

class Parameter : public ::google::protobuf::Message {
 public:
  Parameter();
  virtual ~Parameter();

  Parameter(const Parameter& from);

  inline Parameter& operator=(const Parameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Parameter& default_instance();

  void Swap(Parameter* other);

  // implements Message ----------------------------------------------

  Parameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Parameter& from);
  void MergeFrom(const Parameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // required string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:mesos.Parameter)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* key_;
  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static Parameter* default_instance_;
};
// -------------------------------------------------------------------

class Parameters : public ::google::protobuf::Message {
 public:
  Parameters();
  virtual ~Parameters();

  Parameters(const Parameters& from);

  inline Parameters& operator=(const Parameters& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Parameters& default_instance();

  void Swap(Parameters* other);

  // implements Message ----------------------------------------------

  Parameters* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Parameters& from);
  void MergeFrom(const Parameters& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.Parameter parameter = 1;
  inline int parameter_size() const;
  inline void clear_parameter();
  static const int kParameterFieldNumber = 1;
  inline const ::mesos::Parameter& parameter(int index) const;
  inline ::mesos::Parameter* mutable_parameter(int index);
  inline ::mesos::Parameter* add_parameter();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Parameter >&
      parameter() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Parameter >*
      mutable_parameter();

  // @@protoc_insertion_point(class_scope:mesos.Parameters)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mesos::Parameter > parameter_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static Parameters* default_instance_;
};
// -------------------------------------------------------------------

class Credential : public ::google::protobuf::Message {
 public:
  Credential();
  virtual ~Credential();

  Credential(const Credential& from);

  inline Credential& operator=(const Credential& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Credential& default_instance();

  void Swap(Credential* other);

  // implements Message ----------------------------------------------

  Credential* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Credential& from);
  void MergeFrom(const Credential& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string principal = 1;
  inline bool has_principal() const;
  inline void clear_principal();
  static const int kPrincipalFieldNumber = 1;
  inline const ::std::string& principal() const;
  inline void set_principal(const ::std::string& value);
  inline void set_principal(const char* value);
  inline void set_principal(const char* value, size_t size);
  inline ::std::string* mutable_principal();
  inline ::std::string* release_principal();
  inline void set_allocated_principal(::std::string* principal);

  // optional bytes secret = 2;
  inline bool has_secret() const;
  inline void clear_secret();
  static const int kSecretFieldNumber = 2;
  inline const ::std::string& secret() const;
  inline void set_secret(const ::std::string& value);
  inline void set_secret(const char* value);
  inline void set_secret(const void* value, size_t size);
  inline ::std::string* mutable_secret();
  inline ::std::string* release_secret();
  inline void set_allocated_secret(::std::string* secret);

  // @@protoc_insertion_point(class_scope:mesos.Credential)
 private:
  inline void set_has_principal();
  inline void clear_has_principal();
  inline void set_has_secret();
  inline void clear_has_secret();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* principal_;
  ::std::string* secret_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static Credential* default_instance_;
};
// -------------------------------------------------------------------

class ACL_Entity : public ::google::protobuf::Message {
 public:
  ACL_Entity();
  virtual ~ACL_Entity();

  ACL_Entity(const ACL_Entity& from);

  inline ACL_Entity& operator=(const ACL_Entity& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACL_Entity& default_instance();

  void Swap(ACL_Entity* other);

  // implements Message ----------------------------------------------

  ACL_Entity* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACL_Entity& from);
  void MergeFrom(const ACL_Entity& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ACL_Entity_Type Type;
  static const Type SOME = ACL_Entity_Type_SOME;
  static const Type ANY = ACL_Entity_Type_ANY;
  static const Type NONE = ACL_Entity_Type_NONE;
  static inline bool Type_IsValid(int value) {
    return ACL_Entity_Type_IsValid(value);
  }
  static const Type Type_MIN =
    ACL_Entity_Type_Type_MIN;
  static const Type Type_MAX =
    ACL_Entity_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    ACL_Entity_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return ACL_Entity_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return ACL_Entity_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return ACL_Entity_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .mesos.ACL.Entity.Type type = 1 [default = SOME];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::mesos::ACL_Entity_Type type() const;
  inline void set_type(::mesos::ACL_Entity_Type value);

  // repeated string values = 2;
  inline int values_size() const;
  inline void clear_values();
  static const int kValuesFieldNumber = 2;
  inline const ::std::string& values(int index) const;
  inline ::std::string* mutable_values(int index);
  inline void set_values(int index, const ::std::string& value);
  inline void set_values(int index, const char* value);
  inline void set_values(int index, const char* value, size_t size);
  inline ::std::string* add_values();
  inline void add_values(const ::std::string& value);
  inline void add_values(const char* value);
  inline void add_values(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& values() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_values();

  // @@protoc_insertion_point(class_scope:mesos.ACL.Entity)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> values_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static ACL_Entity* default_instance_;
};
// -------------------------------------------------------------------

class ACL_RunTasks : public ::google::protobuf::Message {
 public:
  ACL_RunTasks();
  virtual ~ACL_RunTasks();

  ACL_RunTasks(const ACL_RunTasks& from);

  inline ACL_RunTasks& operator=(const ACL_RunTasks& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACL_RunTasks& default_instance();

  void Swap(ACL_RunTasks* other);

  // implements Message ----------------------------------------------

  ACL_RunTasks* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACL_RunTasks& from);
  void MergeFrom(const ACL_RunTasks& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ACL.Entity principals = 1;
  inline bool has_principals() const;
  inline void clear_principals();
  static const int kPrincipalsFieldNumber = 1;
  inline const ::mesos::ACL_Entity& principals() const;
  inline ::mesos::ACL_Entity* mutable_principals();
  inline ::mesos::ACL_Entity* release_principals();
  inline void set_allocated_principals(::mesos::ACL_Entity* principals);

  // required .mesos.ACL.Entity users = 2;
  inline bool has_users() const;
  inline void clear_users();
  static const int kUsersFieldNumber = 2;
  inline const ::mesos::ACL_Entity& users() const;
  inline ::mesos::ACL_Entity* mutable_users();
  inline ::mesos::ACL_Entity* release_users();
  inline void set_allocated_users(::mesos::ACL_Entity* users);

  // @@protoc_insertion_point(class_scope:mesos.ACL.RunTasks)
 private:
  inline void set_has_principals();
  inline void clear_has_principals();
  inline void set_has_users();
  inline void clear_has_users();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::ACL_Entity* principals_;
  ::mesos::ACL_Entity* users_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static ACL_RunTasks* default_instance_;
};
// -------------------------------------------------------------------

class ACL_ReceiveOffers : public ::google::protobuf::Message {
 public:
  ACL_ReceiveOffers();
  virtual ~ACL_ReceiveOffers();

  ACL_ReceiveOffers(const ACL_ReceiveOffers& from);

  inline ACL_ReceiveOffers& operator=(const ACL_ReceiveOffers& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACL_ReceiveOffers& default_instance();

  void Swap(ACL_ReceiveOffers* other);

  // implements Message ----------------------------------------------

  ACL_ReceiveOffers* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACL_ReceiveOffers& from);
  void MergeFrom(const ACL_ReceiveOffers& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mesos.ACL.Entity principals = 1;
  inline bool has_principals() const;
  inline void clear_principals();
  static const int kPrincipalsFieldNumber = 1;
  inline const ::mesos::ACL_Entity& principals() const;
  inline ::mesos::ACL_Entity* mutable_principals();
  inline ::mesos::ACL_Entity* release_principals();
  inline void set_allocated_principals(::mesos::ACL_Entity* principals);

  // required .mesos.ACL.Entity roles = 2;
  inline bool has_roles() const;
  inline void clear_roles();
  static const int kRolesFieldNumber = 2;
  inline const ::mesos::ACL_Entity& roles() const;
  inline ::mesos::ACL_Entity* mutable_roles();
  inline ::mesos::ACL_Entity* release_roles();
  inline void set_allocated_roles(::mesos::ACL_Entity* roles);

  // @@protoc_insertion_point(class_scope:mesos.ACL.ReceiveOffers)
 private:
  inline void set_has_principals();
  inline void clear_has_principals();
  inline void set_has_roles();
  inline void clear_has_roles();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::ACL_Entity* principals_;
  ::mesos::ACL_Entity* roles_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static ACL_ReceiveOffers* default_instance_;
};
// -------------------------------------------------------------------

class ACL_HTTPGet : public ::google::protobuf::Message {
 public:
  ACL_HTTPGet();
  virtual ~ACL_HTTPGet();

  ACL_HTTPGet(const ACL_HTTPGet& from);

  inline ACL_HTTPGet& operator=(const ACL_HTTPGet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACL_HTTPGet& default_instance();

  void Swap(ACL_HTTPGet* other);

  // implements Message ----------------------------------------------

  ACL_HTTPGet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACL_HTTPGet& from);
  void MergeFrom(const ACL_HTTPGet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mesos.ACL.Entity usernames = 1;
  inline bool has_usernames() const;
  inline void clear_usernames();
  static const int kUsernamesFieldNumber = 1;
  inline const ::mesos::ACL_Entity& usernames() const;
  inline ::mesos::ACL_Entity* mutable_usernames();
  inline ::mesos::ACL_Entity* release_usernames();
  inline void set_allocated_usernames(::mesos::ACL_Entity* usernames);

  // optional .mesos.ACL.Entity ips = 2;
  inline bool has_ips() const;
  inline void clear_ips();
  static const int kIpsFieldNumber = 2;
  inline const ::mesos::ACL_Entity& ips() const;
  inline ::mesos::ACL_Entity* mutable_ips();
  inline ::mesos::ACL_Entity* release_ips();
  inline void set_allocated_ips(::mesos::ACL_Entity* ips);

  // optional .mesos.ACL.Entity hostnames = 3;
  inline bool has_hostnames() const;
  inline void clear_hostnames();
  static const int kHostnamesFieldNumber = 3;
  inline const ::mesos::ACL_Entity& hostnames() const;
  inline ::mesos::ACL_Entity* mutable_hostnames();
  inline ::mesos::ACL_Entity* release_hostnames();
  inline void set_allocated_hostnames(::mesos::ACL_Entity* hostnames);

  // required .mesos.ACL.Entity urls = 4;
  inline bool has_urls() const;
  inline void clear_urls();
  static const int kUrlsFieldNumber = 4;
  inline const ::mesos::ACL_Entity& urls() const;
  inline ::mesos::ACL_Entity* mutable_urls();
  inline ::mesos::ACL_Entity* release_urls();
  inline void set_allocated_urls(::mesos::ACL_Entity* urls);

  // @@protoc_insertion_point(class_scope:mesos.ACL.HTTPGet)
 private:
  inline void set_has_usernames();
  inline void clear_has_usernames();
  inline void set_has_ips();
  inline void clear_has_ips();
  inline void set_has_hostnames();
  inline void clear_has_hostnames();
  inline void set_has_urls();
  inline void clear_has_urls();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::ACL_Entity* usernames_;
  ::mesos::ACL_Entity* ips_;
  ::mesos::ACL_Entity* hostnames_;
  ::mesos::ACL_Entity* urls_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static ACL_HTTPGet* default_instance_;
};
// -------------------------------------------------------------------

class ACL_HTTPPut : public ::google::protobuf::Message {
 public:
  ACL_HTTPPut();
  virtual ~ACL_HTTPPut();

  ACL_HTTPPut(const ACL_HTTPPut& from);

  inline ACL_HTTPPut& operator=(const ACL_HTTPPut& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACL_HTTPPut& default_instance();

  void Swap(ACL_HTTPPut* other);

  // implements Message ----------------------------------------------

  ACL_HTTPPut* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACL_HTTPPut& from);
  void MergeFrom(const ACL_HTTPPut& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mesos.ACL.Entity usernames = 1;
  inline bool has_usernames() const;
  inline void clear_usernames();
  static const int kUsernamesFieldNumber = 1;
  inline const ::mesos::ACL_Entity& usernames() const;
  inline ::mesos::ACL_Entity* mutable_usernames();
  inline ::mesos::ACL_Entity* release_usernames();
  inline void set_allocated_usernames(::mesos::ACL_Entity* usernames);

  // optional .mesos.ACL.Entity ips = 2;
  inline bool has_ips() const;
  inline void clear_ips();
  static const int kIpsFieldNumber = 2;
  inline const ::mesos::ACL_Entity& ips() const;
  inline ::mesos::ACL_Entity* mutable_ips();
  inline ::mesos::ACL_Entity* release_ips();
  inline void set_allocated_ips(::mesos::ACL_Entity* ips);

  // optional .mesos.ACL.Entity hostnames = 3;
  inline bool has_hostnames() const;
  inline void clear_hostnames();
  static const int kHostnamesFieldNumber = 3;
  inline const ::mesos::ACL_Entity& hostnames() const;
  inline ::mesos::ACL_Entity* mutable_hostnames();
  inline ::mesos::ACL_Entity* release_hostnames();
  inline void set_allocated_hostnames(::mesos::ACL_Entity* hostnames);

  // required .mesos.ACL.Entity urls = 4;
  inline bool has_urls() const;
  inline void clear_urls();
  static const int kUrlsFieldNumber = 4;
  inline const ::mesos::ACL_Entity& urls() const;
  inline ::mesos::ACL_Entity* mutable_urls();
  inline ::mesos::ACL_Entity* release_urls();
  inline void set_allocated_urls(::mesos::ACL_Entity* urls);

  // @@protoc_insertion_point(class_scope:mesos.ACL.HTTPPut)
 private:
  inline void set_has_usernames();
  inline void clear_has_usernames();
  inline void set_has_ips();
  inline void clear_has_ips();
  inline void set_has_hostnames();
  inline void clear_has_hostnames();
  inline void set_has_urls();
  inline void clear_has_urls();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::ACL_Entity* usernames_;
  ::mesos::ACL_Entity* ips_;
  ::mesos::ACL_Entity* hostnames_;
  ::mesos::ACL_Entity* urls_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static ACL_HTTPPut* default_instance_;
};
// -------------------------------------------------------------------

class ACL : public ::google::protobuf::Message {
 public:
  ACL();
  virtual ~ACL();

  ACL(const ACL& from);

  inline ACL& operator=(const ACL& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACL& default_instance();

  void Swap(ACL* other);

  // implements Message ----------------------------------------------

  ACL* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACL& from);
  void MergeFrom(const ACL& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ACL_Entity Entity;
  typedef ACL_RunTasks RunTasks;
  typedef ACL_ReceiveOffers ReceiveOffers;
  typedef ACL_HTTPGet HTTPGet;
  typedef ACL_HTTPPut HTTPPut;

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mesos.ACL)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static ACL* default_instance_;
};
// -------------------------------------------------------------------

class ACLs : public ::google::protobuf::Message {
 public:
  ACLs();
  virtual ~ACLs();

  ACLs(const ACLs& from);

  inline ACLs& operator=(const ACLs& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACLs& default_instance();

  void Swap(ACLs* other);

  // implements Message ----------------------------------------------

  ACLs* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACLs& from);
  void MergeFrom(const ACLs& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool permissive = 1 [default = true];
  inline bool has_permissive() const;
  inline void clear_permissive();
  static const int kPermissiveFieldNumber = 1;
  inline bool permissive() const;
  inline void set_permissive(bool value);

  // repeated .mesos.ACL.RunTasks run_tasks = 2;
  inline int run_tasks_size() const;
  inline void clear_run_tasks();
  static const int kRunTasksFieldNumber = 2;
  inline const ::mesos::ACL_RunTasks& run_tasks(int index) const;
  inline ::mesos::ACL_RunTasks* mutable_run_tasks(int index);
  inline ::mesos::ACL_RunTasks* add_run_tasks();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_RunTasks >&
      run_tasks() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::ACL_RunTasks >*
      mutable_run_tasks();

  // repeated .mesos.ACL.ReceiveOffers receive_offers = 3;
  inline int receive_offers_size() const;
  inline void clear_receive_offers();
  static const int kReceiveOffersFieldNumber = 3;
  inline const ::mesos::ACL_ReceiveOffers& receive_offers(int index) const;
  inline ::mesos::ACL_ReceiveOffers* mutable_receive_offers(int index);
  inline ::mesos::ACL_ReceiveOffers* add_receive_offers();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_ReceiveOffers >&
      receive_offers() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::ACL_ReceiveOffers >*
      mutable_receive_offers();

  // repeated .mesos.ACL.HTTPGet http_get = 4;
  inline int http_get_size() const;
  inline void clear_http_get();
  static const int kHttpGetFieldNumber = 4;
  inline const ::mesos::ACL_HTTPGet& http_get(int index) const;
  inline ::mesos::ACL_HTTPGet* mutable_http_get(int index);
  inline ::mesos::ACL_HTTPGet* add_http_get();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_HTTPGet >&
      http_get() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::ACL_HTTPGet >*
      mutable_http_get();

  // repeated .mesos.ACL.HTTPPut http_put = 5;
  inline int http_put_size() const;
  inline void clear_http_put();
  static const int kHttpPutFieldNumber = 5;
  inline const ::mesos::ACL_HTTPPut& http_put(int index) const;
  inline ::mesos::ACL_HTTPPut* mutable_http_put(int index);
  inline ::mesos::ACL_HTTPPut* add_http_put();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_HTTPPut >&
      http_put() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::ACL_HTTPPut >*
      mutable_http_put();

  // @@protoc_insertion_point(class_scope:mesos.ACLs)
 private:
  inline void set_has_permissive();
  inline void clear_has_permissive();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_RunTasks > run_tasks_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_ReceiveOffers > receive_offers_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_HTTPGet > http_get_;
  ::google::protobuf::RepeatedPtrField< ::mesos::ACL_HTTPPut > http_put_;
  bool permissive_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_mesos_2eproto();
  friend void protobuf_AssignDesc_mesos_2eproto();
  friend void protobuf_ShutdownFile_mesos_2eproto();

  void InitAsDefaultInstance();
  static ACLs* default_instance_;
};
// ===================================================================


// ===================================================================

// FrameworkID

// required string value = 1;
inline bool FrameworkID::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FrameworkID::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FrameworkID::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FrameworkID::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& FrameworkID::value() const {
  return *value_;
}
inline void FrameworkID::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void FrameworkID::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void FrameworkID::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FrameworkID::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* FrameworkID::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FrameworkID::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// OfferID

// required string value = 1;
inline bool OfferID::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OfferID::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OfferID::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OfferID::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& OfferID::value() const {
  return *value_;
}
inline void OfferID::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void OfferID::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void OfferID::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OfferID::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* OfferID::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OfferID::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SlaveID

// required string value = 1;
inline bool SlaveID::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SlaveID::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SlaveID::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SlaveID::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& SlaveID::value() const {
  return *value_;
}
inline void SlaveID::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void SlaveID::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void SlaveID::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SlaveID::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* SlaveID::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SlaveID::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TaskID

// required string value = 1;
inline bool TaskID::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TaskID::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TaskID::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TaskID::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& TaskID::value() const {
  return *value_;
}
inline void TaskID::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void TaskID::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void TaskID::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TaskID::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* TaskID::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TaskID::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ExecutorID

// required string value = 1;
inline bool ExecutorID::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExecutorID::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExecutorID::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExecutorID::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& ExecutorID::value() const {
  return *value_;
}
inline void ExecutorID::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void ExecutorID::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void ExecutorID::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutorID::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* ExecutorID::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExecutorID::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ContainerID

// required string value = 1;
inline bool ContainerID::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContainerID::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContainerID::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContainerID::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& ContainerID::value() const {
  return *value_;
}
inline void ContainerID::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void ContainerID::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void ContainerID::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ContainerID::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* ContainerID::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ContainerID::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// FrameworkInfo

// required string user = 1;
inline bool FrameworkInfo::has_user() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FrameworkInfo::set_has_user() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FrameworkInfo::clear_has_user() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FrameworkInfo::clear_user() {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    user_->clear();
  }
  clear_has_user();
}
inline const ::std::string& FrameworkInfo::user() const {
  return *user_;
}
inline void FrameworkInfo::set_user(const ::std::string& value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void FrameworkInfo::set_user(const char* value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void FrameworkInfo::set_user(const char* value, size_t size) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FrameworkInfo::mutable_user() {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  return user_;
}
inline ::std::string* FrameworkInfo::release_user() {
  clear_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_;
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FrameworkInfo::set_allocated_user(::std::string* user) {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    delete user_;
  }
  if (user) {
    set_has_user();
    user_ = user;
  } else {
    clear_has_user();
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string name = 2;
inline bool FrameworkInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FrameworkInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FrameworkInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FrameworkInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& FrameworkInfo::name() const {
  return *name_;
}
inline void FrameworkInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FrameworkInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FrameworkInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FrameworkInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* FrameworkInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FrameworkInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mesos.FrameworkID id = 3;
inline bool FrameworkInfo::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FrameworkInfo::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FrameworkInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FrameworkInfo::clear_id() {
  if (id_ != NULL) id_->::mesos::FrameworkID::Clear();
  clear_has_id();
}
inline const ::mesos::FrameworkID& FrameworkInfo::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::mesos::FrameworkID* FrameworkInfo::mutable_id() {
  set_has_id();
  if (id_ == NULL) id_ = new ::mesos::FrameworkID;
  return id_;
}
inline ::mesos::FrameworkID* FrameworkInfo::release_id() {
  clear_has_id();
  ::mesos::FrameworkID* temp = id_;
  id_ = NULL;
  return temp;
}
inline void FrameworkInfo::set_allocated_id(::mesos::FrameworkID* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
}

// optional double failover_timeout = 4 [default = 0];
inline bool FrameworkInfo::has_failover_timeout() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FrameworkInfo::set_has_failover_timeout() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FrameworkInfo::clear_has_failover_timeout() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FrameworkInfo::clear_failover_timeout() {
  failover_timeout_ = 0;
  clear_has_failover_timeout();
}
inline double FrameworkInfo::failover_timeout() const {
  return failover_timeout_;
}
inline void FrameworkInfo::set_failover_timeout(double value) {
  set_has_failover_timeout();
  failover_timeout_ = value;
}

// optional bool checkpoint = 5 [default = false];
inline bool FrameworkInfo::has_checkpoint() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FrameworkInfo::set_has_checkpoint() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FrameworkInfo::clear_has_checkpoint() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FrameworkInfo::clear_checkpoint() {
  checkpoint_ = false;
  clear_has_checkpoint();
}
inline bool FrameworkInfo::checkpoint() const {
  return checkpoint_;
}
inline void FrameworkInfo::set_checkpoint(bool value) {
  set_has_checkpoint();
  checkpoint_ = value;
}

// optional string role = 6 [default = "*"];
inline bool FrameworkInfo::has_role() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FrameworkInfo::set_has_role() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FrameworkInfo::clear_has_role() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FrameworkInfo::clear_role() {
  if (role_ != _default_role_) {
    role_->assign(*_default_role_);
  }
  clear_has_role();
}
inline const ::std::string& FrameworkInfo::role() const {
  return *role_;
}
inline void FrameworkInfo::set_role(const ::std::string& value) {
  set_has_role();
  if (role_ == _default_role_) {
    role_ = new ::std::string;
  }
  role_->assign(value);
}
inline void FrameworkInfo::set_role(const char* value) {
  set_has_role();
  if (role_ == _default_role_) {
    role_ = new ::std::string;
  }
  role_->assign(value);
}
inline void FrameworkInfo::set_role(const char* value, size_t size) {
  set_has_role();
  if (role_ == _default_role_) {
    role_ = new ::std::string;
  }
  role_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FrameworkInfo::mutable_role() {
  set_has_role();
  if (role_ == _default_role_) {
    role_ = new ::std::string(*_default_role_);
  }
  return role_;
}
inline ::std::string* FrameworkInfo::release_role() {
  clear_has_role();
  if (role_ == _default_role_) {
    return NULL;
  } else {
    ::std::string* temp = role_;
    role_ = const_cast< ::std::string*>(_default_role_);
    return temp;
  }
}
inline void FrameworkInfo::set_allocated_role(::std::string* role) {
  if (role_ != _default_role_) {
    delete role_;
  }
  if (role) {
    set_has_role();
    role_ = role;
  } else {
    clear_has_role();
    role_ = const_cast< ::std::string*>(_default_role_);
  }
}

// optional string hostname = 7;
inline bool FrameworkInfo::has_hostname() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void FrameworkInfo::set_has_hostname() {
  _has_bits_[0] |= 0x00000040u;
}
inline void FrameworkInfo::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void FrameworkInfo::clear_hostname() {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    hostname_->clear();
  }
  clear_has_hostname();
}
inline const ::std::string& FrameworkInfo::hostname() const {
  return *hostname_;
}
inline void FrameworkInfo::set_hostname(const ::std::string& value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void FrameworkInfo::set_hostname(const char* value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void FrameworkInfo::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FrameworkInfo::mutable_hostname() {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  return hostname_;
}
inline ::std::string* FrameworkInfo::release_hostname() {
  clear_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hostname_;
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FrameworkInfo::set_allocated_hostname(::std::string* hostname) {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    delete hostname_;
  }
  if (hostname) {
    set_has_hostname();
    hostname_ = hostname;
  } else {
    clear_has_hostname();
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string principal = 8;
inline bool FrameworkInfo::has_principal() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void FrameworkInfo::set_has_principal() {
  _has_bits_[0] |= 0x00000080u;
}
inline void FrameworkInfo::clear_has_principal() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void FrameworkInfo::clear_principal() {
  if (principal_ != &::google::protobuf::internal::kEmptyString) {
    principal_->clear();
  }
  clear_has_principal();
}
inline const ::std::string& FrameworkInfo::principal() const {
  return *principal_;
}
inline void FrameworkInfo::set_principal(const ::std::string& value) {
  set_has_principal();
  if (principal_ == &::google::protobuf::internal::kEmptyString) {
    principal_ = new ::std::string;
  }
  principal_->assign(value);
}
inline void FrameworkInfo::set_principal(const char* value) {
  set_has_principal();
  if (principal_ == &::google::protobuf::internal::kEmptyString) {
    principal_ = new ::std::string;
  }
  principal_->assign(value);
}
inline void FrameworkInfo::set_principal(const char* value, size_t size) {
  set_has_principal();
  if (principal_ == &::google::protobuf::internal::kEmptyString) {
    principal_ = new ::std::string;
  }
  principal_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FrameworkInfo::mutable_principal() {
  set_has_principal();
  if (principal_ == &::google::protobuf::internal::kEmptyString) {
    principal_ = new ::std::string;
  }
  return principal_;
}
inline ::std::string* FrameworkInfo::release_principal() {
  clear_has_principal();
  if (principal_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = principal_;
    principal_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FrameworkInfo::set_allocated_principal(::std::string* principal) {
  if (principal_ != &::google::protobuf::internal::kEmptyString) {
    delete principal_;
  }
  if (principal) {
    set_has_principal();
    principal_ = principal;
  } else {
    clear_has_principal();
    principal_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// HealthCheck_HTTP

// required uint32 port = 1;
inline bool HealthCheck_HTTP::has_port() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HealthCheck_HTTP::set_has_port() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HealthCheck_HTTP::clear_has_port() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HealthCheck_HTTP::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 HealthCheck_HTTP::port() const {
  return port_;
}
inline void HealthCheck_HTTP::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// optional string path = 2 [default = "/"];
inline bool HealthCheck_HTTP::has_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HealthCheck_HTTP::set_has_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HealthCheck_HTTP::clear_has_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HealthCheck_HTTP::clear_path() {
  if (path_ != _default_path_) {
    path_->assign(*_default_path_);
  }
  clear_has_path();
}
inline const ::std::string& HealthCheck_HTTP::path() const {
  return *path_;
}
inline void HealthCheck_HTTP::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == _default_path_) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void HealthCheck_HTTP::set_path(const char* value) {
  set_has_path();
  if (path_ == _default_path_) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void HealthCheck_HTTP::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == _default_path_) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HealthCheck_HTTP::mutable_path() {
  set_has_path();
  if (path_ == _default_path_) {
    path_ = new ::std::string(*_default_path_);
  }
  return path_;
}
inline ::std::string* HealthCheck_HTTP::release_path() {
  clear_has_path();
  if (path_ == _default_path_) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(_default_path_);
    return temp;
  }
}
inline void HealthCheck_HTTP::set_allocated_path(::std::string* path) {
  if (path_ != _default_path_) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(_default_path_);
  }
}

// repeated uint32 statuses = 4;
inline int HealthCheck_HTTP::statuses_size() const {
  return statuses_.size();
}
inline void HealthCheck_HTTP::clear_statuses() {
  statuses_.Clear();
}
inline ::google::protobuf::uint32 HealthCheck_HTTP::statuses(int index) const {
  return statuses_.Get(index);
}
inline void HealthCheck_HTTP::set_statuses(int index, ::google::protobuf::uint32 value) {
  statuses_.Set(index, value);
}
inline void HealthCheck_HTTP::add_statuses(::google::protobuf::uint32 value) {
  statuses_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
HealthCheck_HTTP::statuses() const {
  return statuses_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
HealthCheck_HTTP::mutable_statuses() {
  return &statuses_;
}

// -------------------------------------------------------------------

// HealthCheck

// optional .mesos.HealthCheck.HTTP http = 1;
inline bool HealthCheck::has_http() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HealthCheck::set_has_http() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HealthCheck::clear_has_http() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HealthCheck::clear_http() {
  if (http_ != NULL) http_->::mesos::HealthCheck_HTTP::Clear();
  clear_has_http();
}
inline const ::mesos::HealthCheck_HTTP& HealthCheck::http() const {
  return http_ != NULL ? *http_ : *default_instance_->http_;
}
inline ::mesos::HealthCheck_HTTP* HealthCheck::mutable_http() {
  set_has_http();
  if (http_ == NULL) http_ = new ::mesos::HealthCheck_HTTP;
  return http_;
}
inline ::mesos::HealthCheck_HTTP* HealthCheck::release_http() {
  clear_has_http();
  ::mesos::HealthCheck_HTTP* temp = http_;
  http_ = NULL;
  return temp;
}
inline void HealthCheck::set_allocated_http(::mesos::HealthCheck_HTTP* http) {
  delete http_;
  http_ = http;
  if (http) {
    set_has_http();
  } else {
    clear_has_http();
  }
}

// optional double delay_seconds = 2 [default = 15];
inline bool HealthCheck::has_delay_seconds() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HealthCheck::set_has_delay_seconds() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HealthCheck::clear_has_delay_seconds() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HealthCheck::clear_delay_seconds() {
  delay_seconds_ = 15;
  clear_has_delay_seconds();
}
inline double HealthCheck::delay_seconds() const {
  return delay_seconds_;
}
inline void HealthCheck::set_delay_seconds(double value) {
  set_has_delay_seconds();
  delay_seconds_ = value;
}

// optional double interval_seconds = 3 [default = 10];
inline bool HealthCheck::has_interval_seconds() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HealthCheck::set_has_interval_seconds() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HealthCheck::clear_has_interval_seconds() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HealthCheck::clear_interval_seconds() {
  interval_seconds_ = 10;
  clear_has_interval_seconds();
}
inline double HealthCheck::interval_seconds() const {
  return interval_seconds_;
}
inline void HealthCheck::set_interval_seconds(double value) {
  set_has_interval_seconds();
  interval_seconds_ = value;
}

// optional double timeout_seconds = 4 [default = 20];
inline bool HealthCheck::has_timeout_seconds() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HealthCheck::set_has_timeout_seconds() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HealthCheck::clear_has_timeout_seconds() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HealthCheck::clear_timeout_seconds() {
  timeout_seconds_ = 20;
  clear_has_timeout_seconds();
}
inline double HealthCheck::timeout_seconds() const {
  return timeout_seconds_;
}
inline void HealthCheck::set_timeout_seconds(double value) {
  set_has_timeout_seconds();
  timeout_seconds_ = value;
}

// optional uint32 failures = 5 [default = 3];
inline bool HealthCheck::has_failures() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HealthCheck::set_has_failures() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HealthCheck::clear_has_failures() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HealthCheck::clear_failures() {
  failures_ = 3u;
  clear_has_failures();
}
inline ::google::protobuf::uint32 HealthCheck::failures() const {
  return failures_;
}
inline void HealthCheck::set_failures(::google::protobuf::uint32 value) {
  set_has_failures();
  failures_ = value;
}

// -------------------------------------------------------------------

// CommandInfo_URI

// required string value = 1;
inline bool CommandInfo_URI::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandInfo_URI::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandInfo_URI::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandInfo_URI::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& CommandInfo_URI::value() const {
  return *value_;
}
inline void CommandInfo_URI::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void CommandInfo_URI::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void CommandInfo_URI::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommandInfo_URI::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* CommandInfo_URI::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CommandInfo_URI::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool executable = 2;
inline bool CommandInfo_URI::has_executable() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandInfo_URI::set_has_executable() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandInfo_URI::clear_has_executable() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandInfo_URI::clear_executable() {
  executable_ = false;
  clear_has_executable();
}
inline bool CommandInfo_URI::executable() const {
  return executable_;
}
inline void CommandInfo_URI::set_executable(bool value) {
  set_has_executable();
  executable_ = value;
}

// optional bool extract = 3 [default = true];
inline bool CommandInfo_URI::has_extract() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandInfo_URI::set_has_extract() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandInfo_URI::clear_has_extract() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandInfo_URI::clear_extract() {
  extract_ = true;
  clear_has_extract();
}
inline bool CommandInfo_URI::extract() const {
  return extract_;
}
inline void CommandInfo_URI::set_extract(bool value) {
  set_has_extract();
  extract_ = value;
}

// -------------------------------------------------------------------

// CommandInfo_ContainerInfo

// required string image = 1;
inline bool CommandInfo_ContainerInfo::has_image() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandInfo_ContainerInfo::set_has_image() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandInfo_ContainerInfo::clear_has_image() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandInfo_ContainerInfo::clear_image() {
  if (image_ != &::google::protobuf::internal::kEmptyString) {
    image_->clear();
  }
  clear_has_image();
}
inline const ::std::string& CommandInfo_ContainerInfo::image() const {
  return *image_;
}
inline void CommandInfo_ContainerInfo::set_image(const ::std::string& value) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  image_->assign(value);
}
inline void CommandInfo_ContainerInfo::set_image(const char* value) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  image_->assign(value);
}
inline void CommandInfo_ContainerInfo::set_image(const char* value, size_t size) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  image_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommandInfo_ContainerInfo::mutable_image() {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  return image_;
}
inline ::std::string* CommandInfo_ContainerInfo::release_image() {
  clear_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = image_;
    image_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CommandInfo_ContainerInfo::set_allocated_image(::std::string* image) {
  if (image_ != &::google::protobuf::internal::kEmptyString) {
    delete image_;
  }
  if (image) {
    set_has_image();
    image_ = image;
  } else {
    clear_has_image();
    image_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string options = 2;
inline int CommandInfo_ContainerInfo::options_size() const {
  return options_.size();
}
inline void CommandInfo_ContainerInfo::clear_options() {
  options_.Clear();
}
inline const ::std::string& CommandInfo_ContainerInfo::options(int index) const {
  return options_.Get(index);
}
inline ::std::string* CommandInfo_ContainerInfo::mutable_options(int index) {
  return options_.Mutable(index);
}
inline void CommandInfo_ContainerInfo::set_options(int index, const ::std::string& value) {
  options_.Mutable(index)->assign(value);
}
inline void CommandInfo_ContainerInfo::set_options(int index, const char* value) {
  options_.Mutable(index)->assign(value);
}
inline void CommandInfo_ContainerInfo::set_options(int index, const char* value, size_t size) {
  options_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommandInfo_ContainerInfo::add_options() {
  return options_.Add();
}
inline void CommandInfo_ContainerInfo::add_options(const ::std::string& value) {
  options_.Add()->assign(value);
}
inline void CommandInfo_ContainerInfo::add_options(const char* value) {
  options_.Add()->assign(value);
}
inline void CommandInfo_ContainerInfo::add_options(const char* value, size_t size) {
  options_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CommandInfo_ContainerInfo::options() const {
  return options_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CommandInfo_ContainerInfo::mutable_options() {
  return &options_;
}

// -------------------------------------------------------------------

// CommandInfo

// optional .mesos.CommandInfo.ContainerInfo container = 4;
inline bool CommandInfo::has_container() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandInfo::set_has_container() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandInfo::clear_has_container() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandInfo::clear_container() {
  if (container_ != NULL) container_->::mesos::CommandInfo_ContainerInfo::Clear();
  clear_has_container();
}
inline const ::mesos::CommandInfo_ContainerInfo& CommandInfo::container() const {
  return container_ != NULL ? *container_ : *default_instance_->container_;
}
inline ::mesos::CommandInfo_ContainerInfo* CommandInfo::mutable_container() {
  set_has_container();
  if (container_ == NULL) container_ = new ::mesos::CommandInfo_ContainerInfo;
  return container_;
}
inline ::mesos::CommandInfo_ContainerInfo* CommandInfo::release_container() {
  clear_has_container();
  ::mesos::CommandInfo_ContainerInfo* temp = container_;
  container_ = NULL;
  return temp;
}
inline void CommandInfo::set_allocated_container(::mesos::CommandInfo_ContainerInfo* container) {
  delete container_;
  container_ = container;
  if (container) {
    set_has_container();
  } else {
    clear_has_container();
  }
}

// repeated .mesos.CommandInfo.URI uris = 1;
inline int CommandInfo::uris_size() const {
  return uris_.size();
}
inline void CommandInfo::clear_uris() {
  uris_.Clear();
}
inline const ::mesos::CommandInfo_URI& CommandInfo::uris(int index) const {
  return uris_.Get(index);
}
inline ::mesos::CommandInfo_URI* CommandInfo::mutable_uris(int index) {
  return uris_.Mutable(index);
}
inline ::mesos::CommandInfo_URI* CommandInfo::add_uris() {
  return uris_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::CommandInfo_URI >&
CommandInfo::uris() const {
  return uris_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::CommandInfo_URI >*
CommandInfo::mutable_uris() {
  return &uris_;
}

// optional .mesos.Environment environment = 2;
inline bool CommandInfo::has_environment() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandInfo::set_has_environment() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandInfo::clear_has_environment() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandInfo::clear_environment() {
  if (environment_ != NULL) environment_->::mesos::Environment::Clear();
  clear_has_environment();
}
inline const ::mesos::Environment& CommandInfo::environment() const {
  return environment_ != NULL ? *environment_ : *default_instance_->environment_;
}
inline ::mesos::Environment* CommandInfo::mutable_environment() {
  set_has_environment();
  if (environment_ == NULL) environment_ = new ::mesos::Environment;
  return environment_;
}
inline ::mesos::Environment* CommandInfo::release_environment() {
  clear_has_environment();
  ::mesos::Environment* temp = environment_;
  environment_ = NULL;
  return temp;
}
inline void CommandInfo::set_allocated_environment(::mesos::Environment* environment) {
  delete environment_;
  environment_ = environment;
  if (environment) {
    set_has_environment();
  } else {
    clear_has_environment();
  }
}

// required string value = 3;
inline bool CommandInfo::has_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandInfo::set_has_value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandInfo::clear_has_value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandInfo::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& CommandInfo::value() const {
  return *value_;
}
inline void CommandInfo::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void CommandInfo::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void CommandInfo::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommandInfo::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* CommandInfo::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CommandInfo::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string user = 5;
inline bool CommandInfo::has_user() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandInfo::set_has_user() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandInfo::clear_has_user() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandInfo::clear_user() {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    user_->clear();
  }
  clear_has_user();
}
inline const ::std::string& CommandInfo::user() const {
  return *user_;
}
inline void CommandInfo::set_user(const ::std::string& value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void CommandInfo::set_user(const char* value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void CommandInfo::set_user(const char* value, size_t size) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommandInfo::mutable_user() {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  return user_;
}
inline ::std::string* CommandInfo::release_user() {
  clear_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_;
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CommandInfo::set_allocated_user(::std::string* user) {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    delete user_;
  }
  if (user) {
    set_has_user();
    user_ = user;
  } else {
    clear_has_user();
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mesos.HealthCheck health_check = 6;
inline bool CommandInfo::has_health_check() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CommandInfo::set_has_health_check() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CommandInfo::clear_has_health_check() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CommandInfo::clear_health_check() {
  if (health_check_ != NULL) health_check_->::mesos::HealthCheck::Clear();
  clear_has_health_check();
}
inline const ::mesos::HealthCheck& CommandInfo::health_check() const {
  return health_check_ != NULL ? *health_check_ : *default_instance_->health_check_;
}
inline ::mesos::HealthCheck* CommandInfo::mutable_health_check() {
  set_has_health_check();
  if (health_check_ == NULL) health_check_ = new ::mesos::HealthCheck;
  return health_check_;
}
inline ::mesos::HealthCheck* CommandInfo::release_health_check() {
  clear_has_health_check();
  ::mesos::HealthCheck* temp = health_check_;
  health_check_ = NULL;
  return temp;
}
inline void CommandInfo::set_allocated_health_check(::mesos::HealthCheck* health_check) {
  delete health_check_;
  health_check_ = health_check;
  if (health_check) {
    set_has_health_check();
  } else {
    clear_has_health_check();
  }
}

// -------------------------------------------------------------------

// ExecutorInfo

// required .mesos.ExecutorID executor_id = 1;
inline bool ExecutorInfo::has_executor_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExecutorInfo::set_has_executor_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExecutorInfo::clear_has_executor_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExecutorInfo::clear_executor_id() {
  if (executor_id_ != NULL) executor_id_->::mesos::ExecutorID::Clear();
  clear_has_executor_id();
}
inline const ::mesos::ExecutorID& ExecutorInfo::executor_id() const {
  return executor_id_ != NULL ? *executor_id_ : *default_instance_->executor_id_;
}
inline ::mesos::ExecutorID* ExecutorInfo::mutable_executor_id() {
  set_has_executor_id();
  if (executor_id_ == NULL) executor_id_ = new ::mesos::ExecutorID;
  return executor_id_;
}
inline ::mesos::ExecutorID* ExecutorInfo::release_executor_id() {
  clear_has_executor_id();
  ::mesos::ExecutorID* temp = executor_id_;
  executor_id_ = NULL;
  return temp;
}
inline void ExecutorInfo::set_allocated_executor_id(::mesos::ExecutorID* executor_id) {
  delete executor_id_;
  executor_id_ = executor_id;
  if (executor_id) {
    set_has_executor_id();
  } else {
    clear_has_executor_id();
  }
}

// optional .mesos.FrameworkID framework_id = 8;
inline bool ExecutorInfo::has_framework_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExecutorInfo::set_has_framework_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExecutorInfo::clear_has_framework_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExecutorInfo::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  clear_has_framework_id();
}
inline const ::mesos::FrameworkID& ExecutorInfo::framework_id() const {
  return framework_id_ != NULL ? *framework_id_ : *default_instance_->framework_id_;
}
inline ::mesos::FrameworkID* ExecutorInfo::mutable_framework_id() {
  set_has_framework_id();
  if (framework_id_ == NULL) framework_id_ = new ::mesos::FrameworkID;
  return framework_id_;
}
inline ::mesos::FrameworkID* ExecutorInfo::release_framework_id() {
  clear_has_framework_id();
  ::mesos::FrameworkID* temp = framework_id_;
  framework_id_ = NULL;
  return temp;
}
inline void ExecutorInfo::set_allocated_framework_id(::mesos::FrameworkID* framework_id) {
  delete framework_id_;
  framework_id_ = framework_id;
  if (framework_id) {
    set_has_framework_id();
  } else {
    clear_has_framework_id();
  }
}

// required .mesos.CommandInfo command = 7;
inline bool ExecutorInfo::has_command() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExecutorInfo::set_has_command() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ExecutorInfo::clear_has_command() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ExecutorInfo::clear_command() {
  if (command_ != NULL) command_->::mesos::CommandInfo::Clear();
  clear_has_command();
}
inline const ::mesos::CommandInfo& ExecutorInfo::command() const {
  return command_ != NULL ? *command_ : *default_instance_->command_;
}
inline ::mesos::CommandInfo* ExecutorInfo::mutable_command() {
  set_has_command();
  if (command_ == NULL) command_ = new ::mesos::CommandInfo;
  return command_;
}
inline ::mesos::CommandInfo* ExecutorInfo::release_command() {
  clear_has_command();
  ::mesos::CommandInfo* temp = command_;
  command_ = NULL;
  return temp;
}
inline void ExecutorInfo::set_allocated_command(::mesos::CommandInfo* command) {
  delete command_;
  command_ = command;
  if (command) {
    set_has_command();
  } else {
    clear_has_command();
  }
}

// repeated .mesos.Resource resources = 5;
inline int ExecutorInfo::resources_size() const {
  return resources_.size();
}
inline void ExecutorInfo::clear_resources() {
  resources_.Clear();
}
inline const ::mesos::Resource& ExecutorInfo::resources(int index) const {
  return resources_.Get(index);
}
inline ::mesos::Resource* ExecutorInfo::mutable_resources(int index) {
  return resources_.Mutable(index);
}
inline ::mesos::Resource* ExecutorInfo::add_resources() {
  return resources_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
ExecutorInfo::resources() const {
  return resources_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
ExecutorInfo::mutable_resources() {
  return &resources_;
}

// optional string name = 9;
inline bool ExecutorInfo::has_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ExecutorInfo::set_has_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ExecutorInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ExecutorInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ExecutorInfo::name() const {
  return *name_;
}
inline void ExecutorInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ExecutorInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ExecutorInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutorInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ExecutorInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExecutorInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string source = 10;
inline bool ExecutorInfo::has_source() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ExecutorInfo::set_has_source() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ExecutorInfo::clear_has_source() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ExecutorInfo::clear_source() {
  if (source_ != &::google::protobuf::internal::kEmptyString) {
    source_->clear();
  }
  clear_has_source();
}
inline const ::std::string& ExecutorInfo::source() const {
  return *source_;
}
inline void ExecutorInfo::set_source(const ::std::string& value) {
  set_has_source();
  if (source_ == &::google::protobuf::internal::kEmptyString) {
    source_ = new ::std::string;
  }
  source_->assign(value);
}
inline void ExecutorInfo::set_source(const char* value) {
  set_has_source();
  if (source_ == &::google::protobuf::internal::kEmptyString) {
    source_ = new ::std::string;
  }
  source_->assign(value);
}
inline void ExecutorInfo::set_source(const char* value, size_t size) {
  set_has_source();
  if (source_ == &::google::protobuf::internal::kEmptyString) {
    source_ = new ::std::string;
  }
  source_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutorInfo::mutable_source() {
  set_has_source();
  if (source_ == &::google::protobuf::internal::kEmptyString) {
    source_ = new ::std::string;
  }
  return source_;
}
inline ::std::string* ExecutorInfo::release_source() {
  clear_has_source();
  if (source_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = source_;
    source_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExecutorInfo::set_allocated_source(::std::string* source) {
  if (source_ != &::google::protobuf::internal::kEmptyString) {
    delete source_;
  }
  if (source) {
    set_has_source();
    source_ = source;
  } else {
    clear_has_source();
    source_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes data = 4;
inline bool ExecutorInfo::has_data() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ExecutorInfo::set_has_data() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ExecutorInfo::clear_has_data() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ExecutorInfo::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& ExecutorInfo::data() const {
  return *data_;
}
inline void ExecutorInfo::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void ExecutorInfo::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void ExecutorInfo::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutorInfo::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* ExecutorInfo::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExecutorInfo::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// MasterInfo

// required string id = 1;
inline bool MasterInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MasterInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MasterInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MasterInfo::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& MasterInfo::id() const {
  return *id_;
}
inline void MasterInfo::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void MasterInfo::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void MasterInfo::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MasterInfo::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* MasterInfo::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MasterInfo::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 ip = 2;
inline bool MasterInfo::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MasterInfo::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MasterInfo::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MasterInfo::clear_ip() {
  ip_ = 0u;
  clear_has_ip();
}
inline ::google::protobuf::uint32 MasterInfo::ip() const {
  return ip_;
}
inline void MasterInfo::set_ip(::google::protobuf::uint32 value) {
  set_has_ip();
  ip_ = value;
}

// required uint32 port = 3 [default = 5050];
inline bool MasterInfo::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MasterInfo::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MasterInfo::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MasterInfo::clear_port() {
  port_ = 5050u;
  clear_has_port();
}
inline ::google::protobuf::uint32 MasterInfo::port() const {
  return port_;
}
inline void MasterInfo::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// optional string pid = 4;
inline bool MasterInfo::has_pid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MasterInfo::set_has_pid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MasterInfo::clear_has_pid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MasterInfo::clear_pid() {
  if (pid_ != &::google::protobuf::internal::kEmptyString) {
    pid_->clear();
  }
  clear_has_pid();
}
inline const ::std::string& MasterInfo::pid() const {
  return *pid_;
}
inline void MasterInfo::set_pid(const ::std::string& value) {
  set_has_pid();
  if (pid_ == &::google::protobuf::internal::kEmptyString) {
    pid_ = new ::std::string;
  }
  pid_->assign(value);
}
inline void MasterInfo::set_pid(const char* value) {
  set_has_pid();
  if (pid_ == &::google::protobuf::internal::kEmptyString) {
    pid_ = new ::std::string;
  }
  pid_->assign(value);
}
inline void MasterInfo::set_pid(const char* value, size_t size) {
  set_has_pid();
  if (pid_ == &::google::protobuf::internal::kEmptyString) {
    pid_ = new ::std::string;
  }
  pid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MasterInfo::mutable_pid() {
  set_has_pid();
  if (pid_ == &::google::protobuf::internal::kEmptyString) {
    pid_ = new ::std::string;
  }
  return pid_;
}
inline ::std::string* MasterInfo::release_pid() {
  clear_has_pid();
  if (pid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pid_;
    pid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MasterInfo::set_allocated_pid(::std::string* pid) {
  if (pid_ != &::google::protobuf::internal::kEmptyString) {
    delete pid_;
  }
  if (pid) {
    set_has_pid();
    pid_ = pid;
  } else {
    clear_has_pid();
    pid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string hostname = 5;
inline bool MasterInfo::has_hostname() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MasterInfo::set_has_hostname() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MasterInfo::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MasterInfo::clear_hostname() {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    hostname_->clear();
  }
  clear_has_hostname();
}
inline const ::std::string& MasterInfo::hostname() const {
  return *hostname_;
}
inline void MasterInfo::set_hostname(const ::std::string& value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void MasterInfo::set_hostname(const char* value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void MasterInfo::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MasterInfo::mutable_hostname() {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  return hostname_;
}
inline ::std::string* MasterInfo::release_hostname() {
  clear_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hostname_;
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MasterInfo::set_allocated_hostname(::std::string* hostname) {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    delete hostname_;
  }
  if (hostname) {
    set_has_hostname();
    hostname_ = hostname;
  } else {
    clear_has_hostname();
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SlaveInfo

// required string hostname = 1;
inline bool SlaveInfo::has_hostname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SlaveInfo::set_has_hostname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SlaveInfo::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SlaveInfo::clear_hostname() {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    hostname_->clear();
  }
  clear_has_hostname();
}
inline const ::std::string& SlaveInfo::hostname() const {
  return *hostname_;
}
inline void SlaveInfo::set_hostname(const ::std::string& value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void SlaveInfo::set_hostname(const char* value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void SlaveInfo::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SlaveInfo::mutable_hostname() {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  return hostname_;
}
inline ::std::string* SlaveInfo::release_hostname() {
  clear_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hostname_;
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SlaveInfo::set_allocated_hostname(::std::string* hostname) {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    delete hostname_;
  }
  if (hostname) {
    set_has_hostname();
    hostname_ = hostname;
  } else {
    clear_has_hostname();
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 port = 8 [default = 5051];
inline bool SlaveInfo::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SlaveInfo::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SlaveInfo::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SlaveInfo::clear_port() {
  port_ = 5051;
  clear_has_port();
}
inline ::google::protobuf::int32 SlaveInfo::port() const {
  return port_;
}
inline void SlaveInfo::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
}

// repeated .mesos.Resource resources = 3;
inline int SlaveInfo::resources_size() const {
  return resources_.size();
}
inline void SlaveInfo::clear_resources() {
  resources_.Clear();
}
inline const ::mesos::Resource& SlaveInfo::resources(int index) const {
  return resources_.Get(index);
}
inline ::mesos::Resource* SlaveInfo::mutable_resources(int index) {
  return resources_.Mutable(index);
}
inline ::mesos::Resource* SlaveInfo::add_resources() {
  return resources_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
SlaveInfo::resources() const {
  return resources_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
SlaveInfo::mutable_resources() {
  return &resources_;
}

// repeated .mesos.Attribute attributes = 5;
inline int SlaveInfo::attributes_size() const {
  return attributes_.size();
}
inline void SlaveInfo::clear_attributes() {
  attributes_.Clear();
}
inline const ::mesos::Attribute& SlaveInfo::attributes(int index) const {
  return attributes_.Get(index);
}
inline ::mesos::Attribute* SlaveInfo::mutable_attributes(int index) {
  return attributes_.Mutable(index);
}
inline ::mesos::Attribute* SlaveInfo::add_attributes() {
  return attributes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Attribute >&
SlaveInfo::attributes() const {
  return attributes_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Attribute >*
SlaveInfo::mutable_attributes() {
  return &attributes_;
}

// optional .mesos.SlaveID id = 6;
inline bool SlaveInfo::has_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SlaveInfo::set_has_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SlaveInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SlaveInfo::clear_id() {
  if (id_ != NULL) id_->::mesos::SlaveID::Clear();
  clear_has_id();
}
inline const ::mesos::SlaveID& SlaveInfo::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::mesos::SlaveID* SlaveInfo::mutable_id() {
  set_has_id();
  if (id_ == NULL) id_ = new ::mesos::SlaveID;
  return id_;
}
inline ::mesos::SlaveID* SlaveInfo::release_id() {
  clear_has_id();
  ::mesos::SlaveID* temp = id_;
  id_ = NULL;
  return temp;
}
inline void SlaveInfo::set_allocated_id(::mesos::SlaveID* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
}

// optional bool checkpoint = 7 [default = false];
inline bool SlaveInfo::has_checkpoint() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SlaveInfo::set_has_checkpoint() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SlaveInfo::clear_has_checkpoint() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SlaveInfo::clear_checkpoint() {
  checkpoint_ = false;
  clear_has_checkpoint();
}
inline bool SlaveInfo::checkpoint() const {
  return checkpoint_;
}
inline void SlaveInfo::set_checkpoint(bool value) {
  set_has_checkpoint();
  checkpoint_ = value;
}

// optional string webui_hostname = 2;
inline bool SlaveInfo::has_webui_hostname() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SlaveInfo::set_has_webui_hostname() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SlaveInfo::clear_has_webui_hostname() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SlaveInfo::clear_webui_hostname() {
  if (webui_hostname_ != &::google::protobuf::internal::kEmptyString) {
    webui_hostname_->clear();
  }
  clear_has_webui_hostname();
}
inline const ::std::string& SlaveInfo::webui_hostname() const {
  return *webui_hostname_;
}
inline void SlaveInfo::set_webui_hostname(const ::std::string& value) {
  set_has_webui_hostname();
  if (webui_hostname_ == &::google::protobuf::internal::kEmptyString) {
    webui_hostname_ = new ::std::string;
  }
  webui_hostname_->assign(value);
}
inline void SlaveInfo::set_webui_hostname(const char* value) {
  set_has_webui_hostname();
  if (webui_hostname_ == &::google::protobuf::internal::kEmptyString) {
    webui_hostname_ = new ::std::string;
  }
  webui_hostname_->assign(value);
}
inline void SlaveInfo::set_webui_hostname(const char* value, size_t size) {
  set_has_webui_hostname();
  if (webui_hostname_ == &::google::protobuf::internal::kEmptyString) {
    webui_hostname_ = new ::std::string;
  }
  webui_hostname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SlaveInfo::mutable_webui_hostname() {
  set_has_webui_hostname();
  if (webui_hostname_ == &::google::protobuf::internal::kEmptyString) {
    webui_hostname_ = new ::std::string;
  }
  return webui_hostname_;
}
inline ::std::string* SlaveInfo::release_webui_hostname() {
  clear_has_webui_hostname();
  if (webui_hostname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = webui_hostname_;
    webui_hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SlaveInfo::set_allocated_webui_hostname(::std::string* webui_hostname) {
  if (webui_hostname_ != &::google::protobuf::internal::kEmptyString) {
    delete webui_hostname_;
  }
  if (webui_hostname) {
    set_has_webui_hostname();
    webui_hostname_ = webui_hostname;
  } else {
    clear_has_webui_hostname();
    webui_hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 webui_port = 4 [default = 8081];
inline bool SlaveInfo::has_webui_port() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SlaveInfo::set_has_webui_port() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SlaveInfo::clear_has_webui_port() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SlaveInfo::clear_webui_port() {
  webui_port_ = 8081;
  clear_has_webui_port();
}
inline ::google::protobuf::int32 SlaveInfo::webui_port() const {
  return webui_port_;
}
inline void SlaveInfo::set_webui_port(::google::protobuf::int32 value) {
  set_has_webui_port();
  webui_port_ = value;
}

// -------------------------------------------------------------------

// Value_Scalar

// required double value = 1;
inline bool Value_Scalar::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Value_Scalar::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Value_Scalar::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Value_Scalar::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline double Value_Scalar::value() const {
  return value_;
}
inline void Value_Scalar::set_value(double value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// Value_Range

// required uint64 begin = 1;
inline bool Value_Range::has_begin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Value_Range::set_has_begin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Value_Range::clear_has_begin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Value_Range::clear_begin() {
  begin_ = GOOGLE_ULONGLONG(0);
  clear_has_begin();
}
inline ::google::protobuf::uint64 Value_Range::begin() const {
  return begin_;
}
inline void Value_Range::set_begin(::google::protobuf::uint64 value) {
  set_has_begin();
  begin_ = value;
}

// required uint64 end = 2;
inline bool Value_Range::has_end() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Value_Range::set_has_end() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Value_Range::clear_has_end() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Value_Range::clear_end() {
  end_ = GOOGLE_ULONGLONG(0);
  clear_has_end();
}
inline ::google::protobuf::uint64 Value_Range::end() const {
  return end_;
}
inline void Value_Range::set_end(::google::protobuf::uint64 value) {
  set_has_end();
  end_ = value;
}

// -------------------------------------------------------------------

// Value_Ranges

// repeated .mesos.Value.Range range = 1;
inline int Value_Ranges::range_size() const {
  return range_.size();
}
inline void Value_Ranges::clear_range() {
  range_.Clear();
}
inline const ::mesos::Value_Range& Value_Ranges::range(int index) const {
  return range_.Get(index);
}
inline ::mesos::Value_Range* Value_Ranges::mutable_range(int index) {
  return range_.Mutable(index);
}
inline ::mesos::Value_Range* Value_Ranges::add_range() {
  return range_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Value_Range >&
Value_Ranges::range() const {
  return range_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Value_Range >*
Value_Ranges::mutable_range() {
  return &range_;
}

// -------------------------------------------------------------------

// Value_Set

// repeated string item = 1;
inline int Value_Set::item_size() const {
  return item_.size();
}
inline void Value_Set::clear_item() {
  item_.Clear();
}
inline const ::std::string& Value_Set::item(int index) const {
  return item_.Get(index);
}
inline ::std::string* Value_Set::mutable_item(int index) {
  return item_.Mutable(index);
}
inline void Value_Set::set_item(int index, const ::std::string& value) {
  item_.Mutable(index)->assign(value);
}
inline void Value_Set::set_item(int index, const char* value) {
  item_.Mutable(index)->assign(value);
}
inline void Value_Set::set_item(int index, const char* value, size_t size) {
  item_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Value_Set::add_item() {
  return item_.Add();
}
inline void Value_Set::add_item(const ::std::string& value) {
  item_.Add()->assign(value);
}
inline void Value_Set::add_item(const char* value) {
  item_.Add()->assign(value);
}
inline void Value_Set::add_item(const char* value, size_t size) {
  item_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Value_Set::item() const {
  return item_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Value_Set::mutable_item() {
  return &item_;
}

// -------------------------------------------------------------------

// Value_Text

// required string value = 1;
inline bool Value_Text::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Value_Text::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Value_Text::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Value_Text::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& Value_Text::value() const {
  return *value_;
}
inline void Value_Text::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Value_Text::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Value_Text::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Value_Text::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* Value_Text::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Value_Text::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Value

// required .mesos.Value.Type type = 1;
inline bool Value::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Value::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Value::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Value::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mesos::Value_Type Value::type() const {
  return static_cast< ::mesos::Value_Type >(type_);
}
inline void Value::set_type(::mesos::Value_Type value) {
  assert(::mesos::Value_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .mesos.Value.Scalar scalar = 2;
inline bool Value::has_scalar() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Value::set_has_scalar() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Value::clear_has_scalar() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Value::clear_scalar() {
  if (scalar_ != NULL) scalar_->::mesos::Value_Scalar::Clear();
  clear_has_scalar();
}
inline const ::mesos::Value_Scalar& Value::scalar() const {
  return scalar_ != NULL ? *scalar_ : *default_instance_->scalar_;
}
inline ::mesos::Value_Scalar* Value::mutable_scalar() {
  set_has_scalar();
  if (scalar_ == NULL) scalar_ = new ::mesos::Value_Scalar;
  return scalar_;
}
inline ::mesos::Value_Scalar* Value::release_scalar() {
  clear_has_scalar();
  ::mesos::Value_Scalar* temp = scalar_;
  scalar_ = NULL;
  return temp;
}
inline void Value::set_allocated_scalar(::mesos::Value_Scalar* scalar) {
  delete scalar_;
  scalar_ = scalar;
  if (scalar) {
    set_has_scalar();
  } else {
    clear_has_scalar();
  }
}

// optional .mesos.Value.Ranges ranges = 3;
inline bool Value::has_ranges() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Value::set_has_ranges() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Value::clear_has_ranges() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Value::clear_ranges() {
  if (ranges_ != NULL) ranges_->::mesos::Value_Ranges::Clear();
  clear_has_ranges();
}
inline const ::mesos::Value_Ranges& Value::ranges() const {
  return ranges_ != NULL ? *ranges_ : *default_instance_->ranges_;
}
inline ::mesos::Value_Ranges* Value::mutable_ranges() {
  set_has_ranges();
  if (ranges_ == NULL) ranges_ = new ::mesos::Value_Ranges;
  return ranges_;
}
inline ::mesos::Value_Ranges* Value::release_ranges() {
  clear_has_ranges();
  ::mesos::Value_Ranges* temp = ranges_;
  ranges_ = NULL;
  return temp;
}
inline void Value::set_allocated_ranges(::mesos::Value_Ranges* ranges) {
  delete ranges_;
  ranges_ = ranges;
  if (ranges) {
    set_has_ranges();
  } else {
    clear_has_ranges();
  }
}

// optional .mesos.Value.Set set = 4;
inline bool Value::has_set() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Value::set_has_set() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Value::clear_has_set() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Value::clear_set() {
  if (set_ != NULL) set_->::mesos::Value_Set::Clear();
  clear_has_set();
}
inline const ::mesos::Value_Set& Value::set() const {
  return set_ != NULL ? *set_ : *default_instance_->set_;
}
inline ::mesos::Value_Set* Value::mutable_set() {
  set_has_set();
  if (set_ == NULL) set_ = new ::mesos::Value_Set;
  return set_;
}
inline ::mesos::Value_Set* Value::release_set() {
  clear_has_set();
  ::mesos::Value_Set* temp = set_;
  set_ = NULL;
  return temp;
}
inline void Value::set_allocated_set(::mesos::Value_Set* set) {
  delete set_;
  set_ = set;
  if (set) {
    set_has_set();
  } else {
    clear_has_set();
  }
}

// optional .mesos.Value.Text text = 5;
inline bool Value::has_text() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Value::set_has_text() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Value::clear_has_text() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Value::clear_text() {
  if (text_ != NULL) text_->::mesos::Value_Text::Clear();
  clear_has_text();
}
inline const ::mesos::Value_Text& Value::text() const {
  return text_ != NULL ? *text_ : *default_instance_->text_;
}
inline ::mesos::Value_Text* Value::mutable_text() {
  set_has_text();
  if (text_ == NULL) text_ = new ::mesos::Value_Text;
  return text_;
}
inline ::mesos::Value_Text* Value::release_text() {
  clear_has_text();
  ::mesos::Value_Text* temp = text_;
  text_ = NULL;
  return temp;
}
inline void Value::set_allocated_text(::mesos::Value_Text* text) {
  delete text_;
  text_ = text;
  if (text) {
    set_has_text();
  } else {
    clear_has_text();
  }
}

// -------------------------------------------------------------------

// Attribute

// required string name = 1;
inline bool Attribute::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Attribute::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Attribute::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Attribute::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Attribute::name() const {
  return *name_;
}
inline void Attribute::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Attribute::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Attribute::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Attribute::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Attribute::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Attribute::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .mesos.Value.Type type = 2;
inline bool Attribute::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Attribute::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Attribute::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Attribute::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mesos::Value_Type Attribute::type() const {
  return static_cast< ::mesos::Value_Type >(type_);
}
inline void Attribute::set_type(::mesos::Value_Type value) {
  assert(::mesos::Value_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .mesos.Value.Scalar scalar = 3;
inline bool Attribute::has_scalar() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Attribute::set_has_scalar() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Attribute::clear_has_scalar() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Attribute::clear_scalar() {
  if (scalar_ != NULL) scalar_->::mesos::Value_Scalar::Clear();
  clear_has_scalar();
}
inline const ::mesos::Value_Scalar& Attribute::scalar() const {
  return scalar_ != NULL ? *scalar_ : *default_instance_->scalar_;
}
inline ::mesos::Value_Scalar* Attribute::mutable_scalar() {
  set_has_scalar();
  if (scalar_ == NULL) scalar_ = new ::mesos::Value_Scalar;
  return scalar_;
}
inline ::mesos::Value_Scalar* Attribute::release_scalar() {
  clear_has_scalar();
  ::mesos::Value_Scalar* temp = scalar_;
  scalar_ = NULL;
  return temp;
}
inline void Attribute::set_allocated_scalar(::mesos::Value_Scalar* scalar) {
  delete scalar_;
  scalar_ = scalar;
  if (scalar) {
    set_has_scalar();
  } else {
    clear_has_scalar();
  }
}

// optional .mesos.Value.Ranges ranges = 4;
inline bool Attribute::has_ranges() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Attribute::set_has_ranges() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Attribute::clear_has_ranges() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Attribute::clear_ranges() {
  if (ranges_ != NULL) ranges_->::mesos::Value_Ranges::Clear();
  clear_has_ranges();
}
inline const ::mesos::Value_Ranges& Attribute::ranges() const {
  return ranges_ != NULL ? *ranges_ : *default_instance_->ranges_;
}
inline ::mesos::Value_Ranges* Attribute::mutable_ranges() {
  set_has_ranges();
  if (ranges_ == NULL) ranges_ = new ::mesos::Value_Ranges;
  return ranges_;
}
inline ::mesos::Value_Ranges* Attribute::release_ranges() {
  clear_has_ranges();
  ::mesos::Value_Ranges* temp = ranges_;
  ranges_ = NULL;
  return temp;
}
inline void Attribute::set_allocated_ranges(::mesos::Value_Ranges* ranges) {
  delete ranges_;
  ranges_ = ranges;
  if (ranges) {
    set_has_ranges();
  } else {
    clear_has_ranges();
  }
}

// optional .mesos.Value.Set set = 6;
inline bool Attribute::has_set() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Attribute::set_has_set() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Attribute::clear_has_set() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Attribute::clear_set() {
  if (set_ != NULL) set_->::mesos::Value_Set::Clear();
  clear_has_set();
}
inline const ::mesos::Value_Set& Attribute::set() const {
  return set_ != NULL ? *set_ : *default_instance_->set_;
}
inline ::mesos::Value_Set* Attribute::mutable_set() {
  set_has_set();
  if (set_ == NULL) set_ = new ::mesos::Value_Set;
  return set_;
}
inline ::mesos::Value_Set* Attribute::release_set() {
  clear_has_set();
  ::mesos::Value_Set* temp = set_;
  set_ = NULL;
  return temp;
}
inline void Attribute::set_allocated_set(::mesos::Value_Set* set) {
  delete set_;
  set_ = set;
  if (set) {
    set_has_set();
  } else {
    clear_has_set();
  }
}

// optional .mesos.Value.Text text = 5;
inline bool Attribute::has_text() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Attribute::set_has_text() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Attribute::clear_has_text() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Attribute::clear_text() {
  if (text_ != NULL) text_->::mesos::Value_Text::Clear();
  clear_has_text();
}
inline const ::mesos::Value_Text& Attribute::text() const {
  return text_ != NULL ? *text_ : *default_instance_->text_;
}
inline ::mesos::Value_Text* Attribute::mutable_text() {
  set_has_text();
  if (text_ == NULL) text_ = new ::mesos::Value_Text;
  return text_;
}
inline ::mesos::Value_Text* Attribute::release_text() {
  clear_has_text();
  ::mesos::Value_Text* temp = text_;
  text_ = NULL;
  return temp;
}
inline void Attribute::set_allocated_text(::mesos::Value_Text* text) {
  delete text_;
  text_ = text;
  if (text) {
    set_has_text();
  } else {
    clear_has_text();
  }
}

// -------------------------------------------------------------------

// Resource

// required string name = 1;
inline bool Resource::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Resource::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Resource::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Resource::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Resource::name() const {
  return *name_;
}
inline void Resource::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Resource::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Resource::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Resource::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Resource::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Resource::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .mesos.Value.Type type = 2;
inline bool Resource::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Resource::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Resource::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Resource::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mesos::Value_Type Resource::type() const {
  return static_cast< ::mesos::Value_Type >(type_);
}
inline void Resource::set_type(::mesos::Value_Type value) {
  assert(::mesos::Value_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .mesos.Value.Scalar scalar = 3;
inline bool Resource::has_scalar() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Resource::set_has_scalar() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Resource::clear_has_scalar() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Resource::clear_scalar() {
  if (scalar_ != NULL) scalar_->::mesos::Value_Scalar::Clear();
  clear_has_scalar();
}
inline const ::mesos::Value_Scalar& Resource::scalar() const {
  return scalar_ != NULL ? *scalar_ : *default_instance_->scalar_;
}
inline ::mesos::Value_Scalar* Resource::mutable_scalar() {
  set_has_scalar();
  if (scalar_ == NULL) scalar_ = new ::mesos::Value_Scalar;
  return scalar_;
}
inline ::mesos::Value_Scalar* Resource::release_scalar() {
  clear_has_scalar();
  ::mesos::Value_Scalar* temp = scalar_;
  scalar_ = NULL;
  return temp;
}
inline void Resource::set_allocated_scalar(::mesos::Value_Scalar* scalar) {
  delete scalar_;
  scalar_ = scalar;
  if (scalar) {
    set_has_scalar();
  } else {
    clear_has_scalar();
  }
}

// optional .mesos.Value.Ranges ranges = 4;
inline bool Resource::has_ranges() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Resource::set_has_ranges() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Resource::clear_has_ranges() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Resource::clear_ranges() {
  if (ranges_ != NULL) ranges_->::mesos::Value_Ranges::Clear();
  clear_has_ranges();
}
inline const ::mesos::Value_Ranges& Resource::ranges() const {
  return ranges_ != NULL ? *ranges_ : *default_instance_->ranges_;
}
inline ::mesos::Value_Ranges* Resource::mutable_ranges() {
  set_has_ranges();
  if (ranges_ == NULL) ranges_ = new ::mesos::Value_Ranges;
  return ranges_;
}
inline ::mesos::Value_Ranges* Resource::release_ranges() {
  clear_has_ranges();
  ::mesos::Value_Ranges* temp = ranges_;
  ranges_ = NULL;
  return temp;
}
inline void Resource::set_allocated_ranges(::mesos::Value_Ranges* ranges) {
  delete ranges_;
  ranges_ = ranges;
  if (ranges) {
    set_has_ranges();
  } else {
    clear_has_ranges();
  }
}

// optional .mesos.Value.Set set = 5;
inline bool Resource::has_set() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Resource::set_has_set() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Resource::clear_has_set() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Resource::clear_set() {
  if (set_ != NULL) set_->::mesos::Value_Set::Clear();
  clear_has_set();
}
inline const ::mesos::Value_Set& Resource::set() const {
  return set_ != NULL ? *set_ : *default_instance_->set_;
}
inline ::mesos::Value_Set* Resource::mutable_set() {
  set_has_set();
  if (set_ == NULL) set_ = new ::mesos::Value_Set;
  return set_;
}
inline ::mesos::Value_Set* Resource::release_set() {
  clear_has_set();
  ::mesos::Value_Set* temp = set_;
  set_ = NULL;
  return temp;
}
inline void Resource::set_allocated_set(::mesos::Value_Set* set) {
  delete set_;
  set_ = set;
  if (set) {
    set_has_set();
  } else {
    clear_has_set();
  }
}

// optional string role = 6 [default = "*"];
inline bool Resource::has_role() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Resource::set_has_role() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Resource::clear_has_role() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Resource::clear_role() {
  if (role_ != _default_role_) {
    role_->assign(*_default_role_);
  }
  clear_has_role();
}
inline const ::std::string& Resource::role() const {
  return *role_;
}
inline void Resource::set_role(const ::std::string& value) {
  set_has_role();
  if (role_ == _default_role_) {
    role_ = new ::std::string;
  }
  role_->assign(value);
}
inline void Resource::set_role(const char* value) {
  set_has_role();
  if (role_ == _default_role_) {
    role_ = new ::std::string;
  }
  role_->assign(value);
}
inline void Resource::set_role(const char* value, size_t size) {
  set_has_role();
  if (role_ == _default_role_) {
    role_ = new ::std::string;
  }
  role_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Resource::mutable_role() {
  set_has_role();
  if (role_ == _default_role_) {
    role_ = new ::std::string(*_default_role_);
  }
  return role_;
}
inline ::std::string* Resource::release_role() {
  clear_has_role();
  if (role_ == _default_role_) {
    return NULL;
  } else {
    ::std::string* temp = role_;
    role_ = const_cast< ::std::string*>(_default_role_);
    return temp;
  }
}
inline void Resource::set_allocated_role(::std::string* role) {
  if (role_ != _default_role_) {
    delete role_;
  }
  if (role) {
    set_has_role();
    role_ = role;
  } else {
    clear_has_role();
    role_ = const_cast< ::std::string*>(_default_role_);
  }
}

// -------------------------------------------------------------------

// ResourceStatistics

// required double timestamp = 1;
inline bool ResourceStatistics::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResourceStatistics::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResourceStatistics::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResourceStatistics::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline double ResourceStatistics::timestamp() const {
  return timestamp_;
}
inline void ResourceStatistics::set_timestamp(double value) {
  set_has_timestamp();
  timestamp_ = value;
}

// optional double cpus_user_time_secs = 2;
inline bool ResourceStatistics::has_cpus_user_time_secs() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResourceStatistics::set_has_cpus_user_time_secs() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResourceStatistics::clear_has_cpus_user_time_secs() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResourceStatistics::clear_cpus_user_time_secs() {
  cpus_user_time_secs_ = 0;
  clear_has_cpus_user_time_secs();
}
inline double ResourceStatistics::cpus_user_time_secs() const {
  return cpus_user_time_secs_;
}
inline void ResourceStatistics::set_cpus_user_time_secs(double value) {
  set_has_cpus_user_time_secs();
  cpus_user_time_secs_ = value;
}

// optional double cpus_system_time_secs = 3;
inline bool ResourceStatistics::has_cpus_system_time_secs() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResourceStatistics::set_has_cpus_system_time_secs() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResourceStatistics::clear_has_cpus_system_time_secs() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResourceStatistics::clear_cpus_system_time_secs() {
  cpus_system_time_secs_ = 0;
  clear_has_cpus_system_time_secs();
}
inline double ResourceStatistics::cpus_system_time_secs() const {
  return cpus_system_time_secs_;
}
inline void ResourceStatistics::set_cpus_system_time_secs(double value) {
  set_has_cpus_system_time_secs();
  cpus_system_time_secs_ = value;
}

// optional double cpus_limit = 4;
inline bool ResourceStatistics::has_cpus_limit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResourceStatistics::set_has_cpus_limit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResourceStatistics::clear_has_cpus_limit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResourceStatistics::clear_cpus_limit() {
  cpus_limit_ = 0;
  clear_has_cpus_limit();
}
inline double ResourceStatistics::cpus_limit() const {
  return cpus_limit_;
}
inline void ResourceStatistics::set_cpus_limit(double value) {
  set_has_cpus_limit();
  cpus_limit_ = value;
}

// optional uint32 cpus_nr_periods = 7;
inline bool ResourceStatistics::has_cpus_nr_periods() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ResourceStatistics::set_has_cpus_nr_periods() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ResourceStatistics::clear_has_cpus_nr_periods() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ResourceStatistics::clear_cpus_nr_periods() {
  cpus_nr_periods_ = 0u;
  clear_has_cpus_nr_periods();
}
inline ::google::protobuf::uint32 ResourceStatistics::cpus_nr_periods() const {
  return cpus_nr_periods_;
}
inline void ResourceStatistics::set_cpus_nr_periods(::google::protobuf::uint32 value) {
  set_has_cpus_nr_periods();
  cpus_nr_periods_ = value;
}

// optional uint32 cpus_nr_throttled = 8;
inline bool ResourceStatistics::has_cpus_nr_throttled() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ResourceStatistics::set_has_cpus_nr_throttled() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ResourceStatistics::clear_has_cpus_nr_throttled() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ResourceStatistics::clear_cpus_nr_throttled() {
  cpus_nr_throttled_ = 0u;
  clear_has_cpus_nr_throttled();
}
inline ::google::protobuf::uint32 ResourceStatistics::cpus_nr_throttled() const {
  return cpus_nr_throttled_;
}
inline void ResourceStatistics::set_cpus_nr_throttled(::google::protobuf::uint32 value) {
  set_has_cpus_nr_throttled();
  cpus_nr_throttled_ = value;
}

// optional double cpus_throttled_time_secs = 9;
inline bool ResourceStatistics::has_cpus_throttled_time_secs() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ResourceStatistics::set_has_cpus_throttled_time_secs() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ResourceStatistics::clear_has_cpus_throttled_time_secs() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ResourceStatistics::clear_cpus_throttled_time_secs() {
  cpus_throttled_time_secs_ = 0;
  clear_has_cpus_throttled_time_secs();
}
inline double ResourceStatistics::cpus_throttled_time_secs() const {
  return cpus_throttled_time_secs_;
}
inline void ResourceStatistics::set_cpus_throttled_time_secs(double value) {
  set_has_cpus_throttled_time_secs();
  cpus_throttled_time_secs_ = value;
}

// optional uint64 mem_rss_bytes = 5;
inline bool ResourceStatistics::has_mem_rss_bytes() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ResourceStatistics::set_has_mem_rss_bytes() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ResourceStatistics::clear_has_mem_rss_bytes() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ResourceStatistics::clear_mem_rss_bytes() {
  mem_rss_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_mem_rss_bytes();
}
inline ::google::protobuf::uint64 ResourceStatistics::mem_rss_bytes() const {
  return mem_rss_bytes_;
}
inline void ResourceStatistics::set_mem_rss_bytes(::google::protobuf::uint64 value) {
  set_has_mem_rss_bytes();
  mem_rss_bytes_ = value;
}

// optional uint64 mem_limit_bytes = 6;
inline bool ResourceStatistics::has_mem_limit_bytes() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ResourceStatistics::set_has_mem_limit_bytes() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ResourceStatistics::clear_has_mem_limit_bytes() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ResourceStatistics::clear_mem_limit_bytes() {
  mem_limit_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_mem_limit_bytes();
}
inline ::google::protobuf::uint64 ResourceStatistics::mem_limit_bytes() const {
  return mem_limit_bytes_;
}
inline void ResourceStatistics::set_mem_limit_bytes(::google::protobuf::uint64 value) {
  set_has_mem_limit_bytes();
  mem_limit_bytes_ = value;
}

// optional uint64 mem_file_bytes = 10;
inline bool ResourceStatistics::has_mem_file_bytes() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ResourceStatistics::set_has_mem_file_bytes() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ResourceStatistics::clear_has_mem_file_bytes() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ResourceStatistics::clear_mem_file_bytes() {
  mem_file_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_mem_file_bytes();
}
inline ::google::protobuf::uint64 ResourceStatistics::mem_file_bytes() const {
  return mem_file_bytes_;
}
inline void ResourceStatistics::set_mem_file_bytes(::google::protobuf::uint64 value) {
  set_has_mem_file_bytes();
  mem_file_bytes_ = value;
}

// optional uint64 mem_anon_bytes = 11;
inline bool ResourceStatistics::has_mem_anon_bytes() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ResourceStatistics::set_has_mem_anon_bytes() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ResourceStatistics::clear_has_mem_anon_bytes() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ResourceStatistics::clear_mem_anon_bytes() {
  mem_anon_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_mem_anon_bytes();
}
inline ::google::protobuf::uint64 ResourceStatistics::mem_anon_bytes() const {
  return mem_anon_bytes_;
}
inline void ResourceStatistics::set_mem_anon_bytes(::google::protobuf::uint64 value) {
  set_has_mem_anon_bytes();
  mem_anon_bytes_ = value;
}

// optional uint64 mem_mapped_file_bytes = 12;
inline bool ResourceStatistics::has_mem_mapped_file_bytes() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ResourceStatistics::set_has_mem_mapped_file_bytes() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ResourceStatistics::clear_has_mem_mapped_file_bytes() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ResourceStatistics::clear_mem_mapped_file_bytes() {
  mem_mapped_file_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_mem_mapped_file_bytes();
}
inline ::google::protobuf::uint64 ResourceStatistics::mem_mapped_file_bytes() const {
  return mem_mapped_file_bytes_;
}
inline void ResourceStatistics::set_mem_mapped_file_bytes(::google::protobuf::uint64 value) {
  set_has_mem_mapped_file_bytes();
  mem_mapped_file_bytes_ = value;
}

// -------------------------------------------------------------------

// ResourceUsage

// required .mesos.SlaveID slave_id = 1;
inline bool ResourceUsage::has_slave_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResourceUsage::set_has_slave_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResourceUsage::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResourceUsage::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  clear_has_slave_id();
}
inline const ::mesos::SlaveID& ResourceUsage::slave_id() const {
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
inline ::mesos::SlaveID* ResourceUsage::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) slave_id_ = new ::mesos::SlaveID;
  return slave_id_;
}
inline ::mesos::SlaveID* ResourceUsage::release_slave_id() {
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
inline void ResourceUsage::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  delete slave_id_;
  slave_id_ = slave_id;
  if (slave_id) {
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
}

// required .mesos.FrameworkID framework_id = 2;
inline bool ResourceUsage::has_framework_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResourceUsage::set_has_framework_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResourceUsage::clear_has_framework_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResourceUsage::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  clear_has_framework_id();
}
inline const ::mesos::FrameworkID& ResourceUsage::framework_id() const {
  return framework_id_ != NULL ? *framework_id_ : *default_instance_->framework_id_;
}
inline ::mesos::FrameworkID* ResourceUsage::mutable_framework_id() {
  set_has_framework_id();
  if (framework_id_ == NULL) framework_id_ = new ::mesos::FrameworkID;
  return framework_id_;
}
inline ::mesos::FrameworkID* ResourceUsage::release_framework_id() {
  clear_has_framework_id();
  ::mesos::FrameworkID* temp = framework_id_;
  framework_id_ = NULL;
  return temp;
}
inline void ResourceUsage::set_allocated_framework_id(::mesos::FrameworkID* framework_id) {
  delete framework_id_;
  framework_id_ = framework_id;
  if (framework_id) {
    set_has_framework_id();
  } else {
    clear_has_framework_id();
  }
}

// optional .mesos.ExecutorID executor_id = 3;
inline bool ResourceUsage::has_executor_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResourceUsage::set_has_executor_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResourceUsage::clear_has_executor_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResourceUsage::clear_executor_id() {
  if (executor_id_ != NULL) executor_id_->::mesos::ExecutorID::Clear();
  clear_has_executor_id();
}
inline const ::mesos::ExecutorID& ResourceUsage::executor_id() const {
  return executor_id_ != NULL ? *executor_id_ : *default_instance_->executor_id_;
}
inline ::mesos::ExecutorID* ResourceUsage::mutable_executor_id() {
  set_has_executor_id();
  if (executor_id_ == NULL) executor_id_ = new ::mesos::ExecutorID;
  return executor_id_;
}
inline ::mesos::ExecutorID* ResourceUsage::release_executor_id() {
  clear_has_executor_id();
  ::mesos::ExecutorID* temp = executor_id_;
  executor_id_ = NULL;
  return temp;
}
inline void ResourceUsage::set_allocated_executor_id(::mesos::ExecutorID* executor_id) {
  delete executor_id_;
  executor_id_ = executor_id;
  if (executor_id) {
    set_has_executor_id();
  } else {
    clear_has_executor_id();
  }
}

// optional string executor_name = 4;
inline bool ResourceUsage::has_executor_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResourceUsage::set_has_executor_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResourceUsage::clear_has_executor_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResourceUsage::clear_executor_name() {
  if (executor_name_ != &::google::protobuf::internal::kEmptyString) {
    executor_name_->clear();
  }
  clear_has_executor_name();
}
inline const ::std::string& ResourceUsage::executor_name() const {
  return *executor_name_;
}
inline void ResourceUsage::set_executor_name(const ::std::string& value) {
  set_has_executor_name();
  if (executor_name_ == &::google::protobuf::internal::kEmptyString) {
    executor_name_ = new ::std::string;
  }
  executor_name_->assign(value);
}
inline void ResourceUsage::set_executor_name(const char* value) {
  set_has_executor_name();
  if (executor_name_ == &::google::protobuf::internal::kEmptyString) {
    executor_name_ = new ::std::string;
  }
  executor_name_->assign(value);
}
inline void ResourceUsage::set_executor_name(const char* value, size_t size) {
  set_has_executor_name();
  if (executor_name_ == &::google::protobuf::internal::kEmptyString) {
    executor_name_ = new ::std::string;
  }
  executor_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResourceUsage::mutable_executor_name() {
  set_has_executor_name();
  if (executor_name_ == &::google::protobuf::internal::kEmptyString) {
    executor_name_ = new ::std::string;
  }
  return executor_name_;
}
inline ::std::string* ResourceUsage::release_executor_name() {
  clear_has_executor_name();
  if (executor_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = executor_name_;
    executor_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResourceUsage::set_allocated_executor_name(::std::string* executor_name) {
  if (executor_name_ != &::google::protobuf::internal::kEmptyString) {
    delete executor_name_;
  }
  if (executor_name) {
    set_has_executor_name();
    executor_name_ = executor_name;
  } else {
    clear_has_executor_name();
    executor_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mesos.TaskID task_id = 5;
inline bool ResourceUsage::has_task_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ResourceUsage::set_has_task_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ResourceUsage::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ResourceUsage::clear_task_id() {
  if (task_id_ != NULL) task_id_->::mesos::TaskID::Clear();
  clear_has_task_id();
}
inline const ::mesos::TaskID& ResourceUsage::task_id() const {
  return task_id_ != NULL ? *task_id_ : *default_instance_->task_id_;
}
inline ::mesos::TaskID* ResourceUsage::mutable_task_id() {
  set_has_task_id();
  if (task_id_ == NULL) task_id_ = new ::mesos::TaskID;
  return task_id_;
}
inline ::mesos::TaskID* ResourceUsage::release_task_id() {
  clear_has_task_id();
  ::mesos::TaskID* temp = task_id_;
  task_id_ = NULL;
  return temp;
}
inline void ResourceUsage::set_allocated_task_id(::mesos::TaskID* task_id) {
  delete task_id_;
  task_id_ = task_id;
  if (task_id) {
    set_has_task_id();
  } else {
    clear_has_task_id();
  }
}

// optional .mesos.ResourceStatistics statistics = 6;
inline bool ResourceUsage::has_statistics() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ResourceUsage::set_has_statistics() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ResourceUsage::clear_has_statistics() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ResourceUsage::clear_statistics() {
  if (statistics_ != NULL) statistics_->::mesos::ResourceStatistics::Clear();
  clear_has_statistics();
}
inline const ::mesos::ResourceStatistics& ResourceUsage::statistics() const {
  return statistics_ != NULL ? *statistics_ : *default_instance_->statistics_;
}
inline ::mesos::ResourceStatistics* ResourceUsage::mutable_statistics() {
  set_has_statistics();
  if (statistics_ == NULL) statistics_ = new ::mesos::ResourceStatistics;
  return statistics_;
}
inline ::mesos::ResourceStatistics* ResourceUsage::release_statistics() {
  clear_has_statistics();
  ::mesos::ResourceStatistics* temp = statistics_;
  statistics_ = NULL;
  return temp;
}
inline void ResourceUsage::set_allocated_statistics(::mesos::ResourceStatistics* statistics) {
  delete statistics_;
  statistics_ = statistics;
  if (statistics) {
    set_has_statistics();
  } else {
    clear_has_statistics();
  }
}

// -------------------------------------------------------------------

// Request

// optional .mesos.SlaveID slave_id = 1;
inline bool Request::has_slave_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request::set_has_slave_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  clear_has_slave_id();
}
inline const ::mesos::SlaveID& Request::slave_id() const {
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
inline ::mesos::SlaveID* Request::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) slave_id_ = new ::mesos::SlaveID;
  return slave_id_;
}
inline ::mesos::SlaveID* Request::release_slave_id() {
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
inline void Request::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  delete slave_id_;
  slave_id_ = slave_id;
  if (slave_id) {
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
}

// repeated .mesos.Resource resources = 2;
inline int Request::resources_size() const {
  return resources_.size();
}
inline void Request::clear_resources() {
  resources_.Clear();
}
inline const ::mesos::Resource& Request::resources(int index) const {
  return resources_.Get(index);
}
inline ::mesos::Resource* Request::mutable_resources(int index) {
  return resources_.Mutable(index);
}
inline ::mesos::Resource* Request::add_resources() {
  return resources_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
Request::resources() const {
  return resources_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
Request::mutable_resources() {
  return &resources_;
}

// -------------------------------------------------------------------

// Offer

// required .mesos.OfferID id = 1;
inline bool Offer::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Offer::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Offer::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Offer::clear_id() {
  if (id_ != NULL) id_->::mesos::OfferID::Clear();
  clear_has_id();
}
inline const ::mesos::OfferID& Offer::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::mesos::OfferID* Offer::mutable_id() {
  set_has_id();
  if (id_ == NULL) id_ = new ::mesos::OfferID;
  return id_;
}
inline ::mesos::OfferID* Offer::release_id() {
  clear_has_id();
  ::mesos::OfferID* temp = id_;
  id_ = NULL;
  return temp;
}
inline void Offer::set_allocated_id(::mesos::OfferID* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
}

// required .mesos.FrameworkID framework_id = 2;
inline bool Offer::has_framework_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Offer::set_has_framework_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Offer::clear_has_framework_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Offer::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  clear_has_framework_id();
}
inline const ::mesos::FrameworkID& Offer::framework_id() const {
  return framework_id_ != NULL ? *framework_id_ : *default_instance_->framework_id_;
}
inline ::mesos::FrameworkID* Offer::mutable_framework_id() {
  set_has_framework_id();
  if (framework_id_ == NULL) framework_id_ = new ::mesos::FrameworkID;
  return framework_id_;
}
inline ::mesos::FrameworkID* Offer::release_framework_id() {
  clear_has_framework_id();
  ::mesos::FrameworkID* temp = framework_id_;
  framework_id_ = NULL;
  return temp;
}
inline void Offer::set_allocated_framework_id(::mesos::FrameworkID* framework_id) {
  delete framework_id_;
  framework_id_ = framework_id;
  if (framework_id) {
    set_has_framework_id();
  } else {
    clear_has_framework_id();
  }
}

// required .mesos.SlaveID slave_id = 3;
inline bool Offer::has_slave_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Offer::set_has_slave_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Offer::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Offer::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  clear_has_slave_id();
}
inline const ::mesos::SlaveID& Offer::slave_id() const {
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
inline ::mesos::SlaveID* Offer::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) slave_id_ = new ::mesos::SlaveID;
  return slave_id_;
}
inline ::mesos::SlaveID* Offer::release_slave_id() {
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
inline void Offer::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  delete slave_id_;
  slave_id_ = slave_id;
  if (slave_id) {
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
}

// required string hostname = 4;
inline bool Offer::has_hostname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Offer::set_has_hostname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Offer::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Offer::clear_hostname() {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    hostname_->clear();
  }
  clear_has_hostname();
}
inline const ::std::string& Offer::hostname() const {
  return *hostname_;
}
inline void Offer::set_hostname(const ::std::string& value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void Offer::set_hostname(const char* value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void Offer::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Offer::mutable_hostname() {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  return hostname_;
}
inline ::std::string* Offer::release_hostname() {
  clear_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hostname_;
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Offer::set_allocated_hostname(::std::string* hostname) {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    delete hostname_;
  }
  if (hostname) {
    set_has_hostname();
    hostname_ = hostname;
  } else {
    clear_has_hostname();
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .mesos.Resource resources = 5;
inline int Offer::resources_size() const {
  return resources_.size();
}
inline void Offer::clear_resources() {
  resources_.Clear();
}
inline const ::mesos::Resource& Offer::resources(int index) const {
  return resources_.Get(index);
}
inline ::mesos::Resource* Offer::mutable_resources(int index) {
  return resources_.Mutable(index);
}
inline ::mesos::Resource* Offer::add_resources() {
  return resources_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
Offer::resources() const {
  return resources_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
Offer::mutable_resources() {
  return &resources_;
}

// repeated .mesos.Attribute attributes = 7;
inline int Offer::attributes_size() const {
  return attributes_.size();
}
inline void Offer::clear_attributes() {
  attributes_.Clear();
}
inline const ::mesos::Attribute& Offer::attributes(int index) const {
  return attributes_.Get(index);
}
inline ::mesos::Attribute* Offer::mutable_attributes(int index) {
  return attributes_.Mutable(index);
}
inline ::mesos::Attribute* Offer::add_attributes() {
  return attributes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Attribute >&
Offer::attributes() const {
  return attributes_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Attribute >*
Offer::mutable_attributes() {
  return &attributes_;
}

// repeated .mesos.ExecutorID executor_ids = 6;
inline int Offer::executor_ids_size() const {
  return executor_ids_.size();
}
inline void Offer::clear_executor_ids() {
  executor_ids_.Clear();
}
inline const ::mesos::ExecutorID& Offer::executor_ids(int index) const {
  return executor_ids_.Get(index);
}
inline ::mesos::ExecutorID* Offer::mutable_executor_ids(int index) {
  return executor_ids_.Mutable(index);
}
inline ::mesos::ExecutorID* Offer::add_executor_ids() {
  return executor_ids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ExecutorID >&
Offer::executor_ids() const {
  return executor_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ExecutorID >*
Offer::mutable_executor_ids() {
  return &executor_ids_;
}

// -------------------------------------------------------------------

// TaskInfo

// required string name = 1;
inline bool TaskInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TaskInfo::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TaskInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TaskInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TaskInfo::name() const {
  return *name_;
}
inline void TaskInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TaskInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TaskInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TaskInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TaskInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TaskInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .mesos.TaskID task_id = 2;
inline bool TaskInfo::has_task_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TaskInfo::set_has_task_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TaskInfo::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TaskInfo::clear_task_id() {
  if (task_id_ != NULL) task_id_->::mesos::TaskID::Clear();
  clear_has_task_id();
}
inline const ::mesos::TaskID& TaskInfo::task_id() const {
  return task_id_ != NULL ? *task_id_ : *default_instance_->task_id_;
}
inline ::mesos::TaskID* TaskInfo::mutable_task_id() {
  set_has_task_id();
  if (task_id_ == NULL) task_id_ = new ::mesos::TaskID;
  return task_id_;
}
inline ::mesos::TaskID* TaskInfo::release_task_id() {
  clear_has_task_id();
  ::mesos::TaskID* temp = task_id_;
  task_id_ = NULL;
  return temp;
}
inline void TaskInfo::set_allocated_task_id(::mesos::TaskID* task_id) {
  delete task_id_;
  task_id_ = task_id;
  if (task_id) {
    set_has_task_id();
  } else {
    clear_has_task_id();
  }
}

// required .mesos.SlaveID slave_id = 3;
inline bool TaskInfo::has_slave_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TaskInfo::set_has_slave_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TaskInfo::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TaskInfo::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  clear_has_slave_id();
}
inline const ::mesos::SlaveID& TaskInfo::slave_id() const {
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
inline ::mesos::SlaveID* TaskInfo::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) slave_id_ = new ::mesos::SlaveID;
  return slave_id_;
}
inline ::mesos::SlaveID* TaskInfo::release_slave_id() {
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
inline void TaskInfo::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  delete slave_id_;
  slave_id_ = slave_id;
  if (slave_id) {
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
}

// repeated .mesos.Resource resources = 4;
inline int TaskInfo::resources_size() const {
  return resources_.size();
}
inline void TaskInfo::clear_resources() {
  resources_.Clear();
}
inline const ::mesos::Resource& TaskInfo::resources(int index) const {
  return resources_.Get(index);
}
inline ::mesos::Resource* TaskInfo::mutable_resources(int index) {
  return resources_.Mutable(index);
}
inline ::mesos::Resource* TaskInfo::add_resources() {
  return resources_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
TaskInfo::resources() const {
  return resources_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
TaskInfo::mutable_resources() {
  return &resources_;
}

// optional .mesos.ExecutorInfo executor = 5;
inline bool TaskInfo::has_executor() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TaskInfo::set_has_executor() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TaskInfo::clear_has_executor() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TaskInfo::clear_executor() {
  if (executor_ != NULL) executor_->::mesos::ExecutorInfo::Clear();
  clear_has_executor();
}
inline const ::mesos::ExecutorInfo& TaskInfo::executor() const {
  return executor_ != NULL ? *executor_ : *default_instance_->executor_;
}
inline ::mesos::ExecutorInfo* TaskInfo::mutable_executor() {
  set_has_executor();
  if (executor_ == NULL) executor_ = new ::mesos::ExecutorInfo;
  return executor_;
}
inline ::mesos::ExecutorInfo* TaskInfo::release_executor() {
  clear_has_executor();
  ::mesos::ExecutorInfo* temp = executor_;
  executor_ = NULL;
  return temp;
}
inline void TaskInfo::set_allocated_executor(::mesos::ExecutorInfo* executor) {
  delete executor_;
  executor_ = executor;
  if (executor) {
    set_has_executor();
  } else {
    clear_has_executor();
  }
}

// optional .mesos.CommandInfo command = 7;
inline bool TaskInfo::has_command() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TaskInfo::set_has_command() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TaskInfo::clear_has_command() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TaskInfo::clear_command() {
  if (command_ != NULL) command_->::mesos::CommandInfo::Clear();
  clear_has_command();
}
inline const ::mesos::CommandInfo& TaskInfo::command() const {
  return command_ != NULL ? *command_ : *default_instance_->command_;
}
inline ::mesos::CommandInfo* TaskInfo::mutable_command() {
  set_has_command();
  if (command_ == NULL) command_ = new ::mesos::CommandInfo;
  return command_;
}
inline ::mesos::CommandInfo* TaskInfo::release_command() {
  clear_has_command();
  ::mesos::CommandInfo* temp = command_;
  command_ = NULL;
  return temp;
}
inline void TaskInfo::set_allocated_command(::mesos::CommandInfo* command) {
  delete command_;
  command_ = command;
  if (command) {
    set_has_command();
  } else {
    clear_has_command();
  }
}

// optional bytes data = 6;
inline bool TaskInfo::has_data() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TaskInfo::set_has_data() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TaskInfo::clear_has_data() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TaskInfo::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& TaskInfo::data() const {
  return *data_;
}
inline void TaskInfo::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void TaskInfo::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void TaskInfo::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TaskInfo::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* TaskInfo::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TaskInfo::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TaskStatus

// required .mesos.TaskID task_id = 1;
inline bool TaskStatus::has_task_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TaskStatus::set_has_task_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TaskStatus::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TaskStatus::clear_task_id() {
  if (task_id_ != NULL) task_id_->::mesos::TaskID::Clear();
  clear_has_task_id();
}
inline const ::mesos::TaskID& TaskStatus::task_id() const {
  return task_id_ != NULL ? *task_id_ : *default_instance_->task_id_;
}
inline ::mesos::TaskID* TaskStatus::mutable_task_id() {
  set_has_task_id();
  if (task_id_ == NULL) task_id_ = new ::mesos::TaskID;
  return task_id_;
}
inline ::mesos::TaskID* TaskStatus::release_task_id() {
  clear_has_task_id();
  ::mesos::TaskID* temp = task_id_;
  task_id_ = NULL;
  return temp;
}
inline void TaskStatus::set_allocated_task_id(::mesos::TaskID* task_id) {
  delete task_id_;
  task_id_ = task_id;
  if (task_id) {
    set_has_task_id();
  } else {
    clear_has_task_id();
  }
}

// required .mesos.TaskState state = 2;
inline bool TaskStatus::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TaskStatus::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TaskStatus::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TaskStatus::clear_state() {
  state_ = 6;
  clear_has_state();
}
inline ::mesos::TaskState TaskStatus::state() const {
  return static_cast< ::mesos::TaskState >(state_);
}
inline void TaskStatus::set_state(::mesos::TaskState value) {
  assert(::mesos::TaskState_IsValid(value));
  set_has_state();
  state_ = value;
}

// optional string message = 4;
inline bool TaskStatus::has_message() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TaskStatus::set_has_message() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TaskStatus::clear_has_message() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TaskStatus::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& TaskStatus::message() const {
  return *message_;
}
inline void TaskStatus::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void TaskStatus::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void TaskStatus::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TaskStatus::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* TaskStatus::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TaskStatus::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes data = 3;
inline bool TaskStatus::has_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TaskStatus::set_has_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TaskStatus::clear_has_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TaskStatus::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& TaskStatus::data() const {
  return *data_;
}
inline void TaskStatus::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void TaskStatus::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void TaskStatus::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TaskStatus::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* TaskStatus::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TaskStatus::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mesos.SlaveID slave_id = 5;
inline bool TaskStatus::has_slave_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TaskStatus::set_has_slave_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TaskStatus::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TaskStatus::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  clear_has_slave_id();
}
inline const ::mesos::SlaveID& TaskStatus::slave_id() const {
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
inline ::mesos::SlaveID* TaskStatus::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) slave_id_ = new ::mesos::SlaveID;
  return slave_id_;
}
inline ::mesos::SlaveID* TaskStatus::release_slave_id() {
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
inline void TaskStatus::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  delete slave_id_;
  slave_id_ = slave_id;
  if (slave_id) {
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
}

// optional double timestamp = 6;
inline bool TaskStatus::has_timestamp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TaskStatus::set_has_timestamp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TaskStatus::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TaskStatus::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline double TaskStatus::timestamp() const {
  return timestamp_;
}
inline void TaskStatus::set_timestamp(double value) {
  set_has_timestamp();
  timestamp_ = value;
}

// -------------------------------------------------------------------

// Filters

// optional double refuse_seconds = 1 [default = 5];
inline bool Filters::has_refuse_seconds() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Filters::set_has_refuse_seconds() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Filters::clear_has_refuse_seconds() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Filters::clear_refuse_seconds() {
  refuse_seconds_ = 5;
  clear_has_refuse_seconds();
}
inline double Filters::refuse_seconds() const {
  return refuse_seconds_;
}
inline void Filters::set_refuse_seconds(double value) {
  set_has_refuse_seconds();
  refuse_seconds_ = value;
}

// -------------------------------------------------------------------

// Environment_Variable

// required string name = 1;
inline bool Environment_Variable::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Environment_Variable::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Environment_Variable::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Environment_Variable::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Environment_Variable::name() const {
  return *name_;
}
inline void Environment_Variable::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Environment_Variable::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Environment_Variable::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Environment_Variable::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Environment_Variable::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Environment_Variable::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string value = 2;
inline bool Environment_Variable::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Environment_Variable::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Environment_Variable::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Environment_Variable::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& Environment_Variable::value() const {
  return *value_;
}
inline void Environment_Variable::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Environment_Variable::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Environment_Variable::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Environment_Variable::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* Environment_Variable::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Environment_Variable::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Environment

// repeated .mesos.Environment.Variable variables = 1;
inline int Environment::variables_size() const {
  return variables_.size();
}
inline void Environment::clear_variables() {
  variables_.Clear();
}
inline const ::mesos::Environment_Variable& Environment::variables(int index) const {
  return variables_.Get(index);
}
inline ::mesos::Environment_Variable* Environment::mutable_variables(int index) {
  return variables_.Mutable(index);
}
inline ::mesos::Environment_Variable* Environment::add_variables() {
  return variables_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Environment_Variable >&
Environment::variables() const {
  return variables_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Environment_Variable >*
Environment::mutable_variables() {
  return &variables_;
}

// -------------------------------------------------------------------

// Parameter

// required string key = 1;
inline bool Parameter::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Parameter::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Parameter::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Parameter::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& Parameter::key() const {
  return *key_;
}
inline void Parameter::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Parameter::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Parameter::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Parameter::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* Parameter::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Parameter::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string value = 2;
inline bool Parameter::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Parameter::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Parameter::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Parameter::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& Parameter::value() const {
  return *value_;
}
inline void Parameter::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Parameter::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Parameter::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Parameter::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* Parameter::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Parameter::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Parameters

// repeated .mesos.Parameter parameter = 1;
inline int Parameters::parameter_size() const {
  return parameter_.size();
}
inline void Parameters::clear_parameter() {
  parameter_.Clear();
}
inline const ::mesos::Parameter& Parameters::parameter(int index) const {
  return parameter_.Get(index);
}
inline ::mesos::Parameter* Parameters::mutable_parameter(int index) {
  return parameter_.Mutable(index);
}
inline ::mesos::Parameter* Parameters::add_parameter() {
  return parameter_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Parameter >&
Parameters::parameter() const {
  return parameter_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Parameter >*
Parameters::mutable_parameter() {
  return &parameter_;
}

// -------------------------------------------------------------------

// Credential

// required string principal = 1;
inline bool Credential::has_principal() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Credential::set_has_principal() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Credential::clear_has_principal() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Credential::clear_principal() {
  if (principal_ != &::google::protobuf::internal::kEmptyString) {
    principal_->clear();
  }
  clear_has_principal();
}
inline const ::std::string& Credential::principal() const {
  return *principal_;
}
inline void Credential::set_principal(const ::std::string& value) {
  set_has_principal();
  if (principal_ == &::google::protobuf::internal::kEmptyString) {
    principal_ = new ::std::string;
  }
  principal_->assign(value);
}
inline void Credential::set_principal(const char* value) {
  set_has_principal();
  if (principal_ == &::google::protobuf::internal::kEmptyString) {
    principal_ = new ::std::string;
  }
  principal_->assign(value);
}
inline void Credential::set_principal(const char* value, size_t size) {
  set_has_principal();
  if (principal_ == &::google::protobuf::internal::kEmptyString) {
    principal_ = new ::std::string;
  }
  principal_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Credential::mutable_principal() {
  set_has_principal();
  if (principal_ == &::google::protobuf::internal::kEmptyString) {
    principal_ = new ::std::string;
  }
  return principal_;
}
inline ::std::string* Credential::release_principal() {
  clear_has_principal();
  if (principal_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = principal_;
    principal_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Credential::set_allocated_principal(::std::string* principal) {
  if (principal_ != &::google::protobuf::internal::kEmptyString) {
    delete principal_;
  }
  if (principal) {
    set_has_principal();
    principal_ = principal;
  } else {
    clear_has_principal();
    principal_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes secret = 2;
inline bool Credential::has_secret() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Credential::set_has_secret() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Credential::clear_has_secret() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Credential::clear_secret() {
  if (secret_ != &::google::protobuf::internal::kEmptyString) {
    secret_->clear();
  }
  clear_has_secret();
}
inline const ::std::string& Credential::secret() const {
  return *secret_;
}
inline void Credential::set_secret(const ::std::string& value) {
  set_has_secret();
  if (secret_ == &::google::protobuf::internal::kEmptyString) {
    secret_ = new ::std::string;
  }
  secret_->assign(value);
}
inline void Credential::set_secret(const char* value) {
  set_has_secret();
  if (secret_ == &::google::protobuf::internal::kEmptyString) {
    secret_ = new ::std::string;
  }
  secret_->assign(value);
}
inline void Credential::set_secret(const void* value, size_t size) {
  set_has_secret();
  if (secret_ == &::google::protobuf::internal::kEmptyString) {
    secret_ = new ::std::string;
  }
  secret_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Credential::mutable_secret() {
  set_has_secret();
  if (secret_ == &::google::protobuf::internal::kEmptyString) {
    secret_ = new ::std::string;
  }
  return secret_;
}
inline ::std::string* Credential::release_secret() {
  clear_has_secret();
  if (secret_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = secret_;
    secret_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Credential::set_allocated_secret(::std::string* secret) {
  if (secret_ != &::google::protobuf::internal::kEmptyString) {
    delete secret_;
  }
  if (secret) {
    set_has_secret();
    secret_ = secret;
  } else {
    clear_has_secret();
    secret_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ACL_Entity

// optional .mesos.ACL.Entity.Type type = 1 [default = SOME];
inline bool ACL_Entity::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACL_Entity::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACL_Entity::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACL_Entity::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mesos::ACL_Entity_Type ACL_Entity::type() const {
  return static_cast< ::mesos::ACL_Entity_Type >(type_);
}
inline void ACL_Entity::set_type(::mesos::ACL_Entity_Type value) {
  assert(::mesos::ACL_Entity_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// repeated string values = 2;
inline int ACL_Entity::values_size() const {
  return values_.size();
}
inline void ACL_Entity::clear_values() {
  values_.Clear();
}
inline const ::std::string& ACL_Entity::values(int index) const {
  return values_.Get(index);
}
inline ::std::string* ACL_Entity::mutable_values(int index) {
  return values_.Mutable(index);
}
inline void ACL_Entity::set_values(int index, const ::std::string& value) {
  values_.Mutable(index)->assign(value);
}
inline void ACL_Entity::set_values(int index, const char* value) {
  values_.Mutable(index)->assign(value);
}
inline void ACL_Entity::set_values(int index, const char* value, size_t size) {
  values_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ACL_Entity::add_values() {
  return values_.Add();
}
inline void ACL_Entity::add_values(const ::std::string& value) {
  values_.Add()->assign(value);
}
inline void ACL_Entity::add_values(const char* value) {
  values_.Add()->assign(value);
}
inline void ACL_Entity::add_values(const char* value, size_t size) {
  values_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ACL_Entity::values() const {
  return values_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ACL_Entity::mutable_values() {
  return &values_;
}

// -------------------------------------------------------------------

// ACL_RunTasks

// required .mesos.ACL.Entity principals = 1;
inline bool ACL_RunTasks::has_principals() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACL_RunTasks::set_has_principals() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACL_RunTasks::clear_has_principals() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACL_RunTasks::clear_principals() {
  if (principals_ != NULL) principals_->::mesos::ACL_Entity::Clear();
  clear_has_principals();
}
inline const ::mesos::ACL_Entity& ACL_RunTasks::principals() const {
  return principals_ != NULL ? *principals_ : *default_instance_->principals_;
}
inline ::mesos::ACL_Entity* ACL_RunTasks::mutable_principals() {
  set_has_principals();
  if (principals_ == NULL) principals_ = new ::mesos::ACL_Entity;
  return principals_;
}
inline ::mesos::ACL_Entity* ACL_RunTasks::release_principals() {
  clear_has_principals();
  ::mesos::ACL_Entity* temp = principals_;
  principals_ = NULL;
  return temp;
}
inline void ACL_RunTasks::set_allocated_principals(::mesos::ACL_Entity* principals) {
  delete principals_;
  principals_ = principals;
  if (principals) {
    set_has_principals();
  } else {
    clear_has_principals();
  }
}

// required .mesos.ACL.Entity users = 2;
inline bool ACL_RunTasks::has_users() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACL_RunTasks::set_has_users() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACL_RunTasks::clear_has_users() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACL_RunTasks::clear_users() {
  if (users_ != NULL) users_->::mesos::ACL_Entity::Clear();
  clear_has_users();
}
inline const ::mesos::ACL_Entity& ACL_RunTasks::users() const {
  return users_ != NULL ? *users_ : *default_instance_->users_;
}
inline ::mesos::ACL_Entity* ACL_RunTasks::mutable_users() {
  set_has_users();
  if (users_ == NULL) users_ = new ::mesos::ACL_Entity;
  return users_;
}
inline ::mesos::ACL_Entity* ACL_RunTasks::release_users() {
  clear_has_users();
  ::mesos::ACL_Entity* temp = users_;
  users_ = NULL;
  return temp;
}
inline void ACL_RunTasks::set_allocated_users(::mesos::ACL_Entity* users) {
  delete users_;
  users_ = users;
  if (users) {
    set_has_users();
  } else {
    clear_has_users();
  }
}

// -------------------------------------------------------------------

// ACL_ReceiveOffers

// required .mesos.ACL.Entity principals = 1;
inline bool ACL_ReceiveOffers::has_principals() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACL_ReceiveOffers::set_has_principals() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACL_ReceiveOffers::clear_has_principals() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACL_ReceiveOffers::clear_principals() {
  if (principals_ != NULL) principals_->::mesos::ACL_Entity::Clear();
  clear_has_principals();
}
inline const ::mesos::ACL_Entity& ACL_ReceiveOffers::principals() const {
  return principals_ != NULL ? *principals_ : *default_instance_->principals_;
}
inline ::mesos::ACL_Entity* ACL_ReceiveOffers::mutable_principals() {
  set_has_principals();
  if (principals_ == NULL) principals_ = new ::mesos::ACL_Entity;
  return principals_;
}
inline ::mesos::ACL_Entity* ACL_ReceiveOffers::release_principals() {
  clear_has_principals();
  ::mesos::ACL_Entity* temp = principals_;
  principals_ = NULL;
  return temp;
}
inline void ACL_ReceiveOffers::set_allocated_principals(::mesos::ACL_Entity* principals) {
  delete principals_;
  principals_ = principals;
  if (principals) {
    set_has_principals();
  } else {
    clear_has_principals();
  }
}

// required .mesos.ACL.Entity roles = 2;
inline bool ACL_ReceiveOffers::has_roles() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACL_ReceiveOffers::set_has_roles() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACL_ReceiveOffers::clear_has_roles() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACL_ReceiveOffers::clear_roles() {
  if (roles_ != NULL) roles_->::mesos::ACL_Entity::Clear();
  clear_has_roles();
}
inline const ::mesos::ACL_Entity& ACL_ReceiveOffers::roles() const {
  return roles_ != NULL ? *roles_ : *default_instance_->roles_;
}
inline ::mesos::ACL_Entity* ACL_ReceiveOffers::mutable_roles() {
  set_has_roles();
  if (roles_ == NULL) roles_ = new ::mesos::ACL_Entity;
  return roles_;
}
inline ::mesos::ACL_Entity* ACL_ReceiveOffers::release_roles() {
  clear_has_roles();
  ::mesos::ACL_Entity* temp = roles_;
  roles_ = NULL;
  return temp;
}
inline void ACL_ReceiveOffers::set_allocated_roles(::mesos::ACL_Entity* roles) {
  delete roles_;
  roles_ = roles;
  if (roles) {
    set_has_roles();
  } else {
    clear_has_roles();
  }
}

// -------------------------------------------------------------------

// ACL_HTTPGet

// optional .mesos.ACL.Entity usernames = 1;
inline bool ACL_HTTPGet::has_usernames() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACL_HTTPGet::set_has_usernames() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACL_HTTPGet::clear_has_usernames() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACL_HTTPGet::clear_usernames() {
  if (usernames_ != NULL) usernames_->::mesos::ACL_Entity::Clear();
  clear_has_usernames();
}
inline const ::mesos::ACL_Entity& ACL_HTTPGet::usernames() const {
  return usernames_ != NULL ? *usernames_ : *default_instance_->usernames_;
}
inline ::mesos::ACL_Entity* ACL_HTTPGet::mutable_usernames() {
  set_has_usernames();
  if (usernames_ == NULL) usernames_ = new ::mesos::ACL_Entity;
  return usernames_;
}
inline ::mesos::ACL_Entity* ACL_HTTPGet::release_usernames() {
  clear_has_usernames();
  ::mesos::ACL_Entity* temp = usernames_;
  usernames_ = NULL;
  return temp;
}
inline void ACL_HTTPGet::set_allocated_usernames(::mesos::ACL_Entity* usernames) {
  delete usernames_;
  usernames_ = usernames;
  if (usernames) {
    set_has_usernames();
  } else {
    clear_has_usernames();
  }
}

// optional .mesos.ACL.Entity ips = 2;
inline bool ACL_HTTPGet::has_ips() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACL_HTTPGet::set_has_ips() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACL_HTTPGet::clear_has_ips() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACL_HTTPGet::clear_ips() {
  if (ips_ != NULL) ips_->::mesos::ACL_Entity::Clear();
  clear_has_ips();
}
inline const ::mesos::ACL_Entity& ACL_HTTPGet::ips() const {
  return ips_ != NULL ? *ips_ : *default_instance_->ips_;
}
inline ::mesos::ACL_Entity* ACL_HTTPGet::mutable_ips() {
  set_has_ips();
  if (ips_ == NULL) ips_ = new ::mesos::ACL_Entity;
  return ips_;
}
inline ::mesos::ACL_Entity* ACL_HTTPGet::release_ips() {
  clear_has_ips();
  ::mesos::ACL_Entity* temp = ips_;
  ips_ = NULL;
  return temp;
}
inline void ACL_HTTPGet::set_allocated_ips(::mesos::ACL_Entity* ips) {
  delete ips_;
  ips_ = ips;
  if (ips) {
    set_has_ips();
  } else {
    clear_has_ips();
  }
}

// optional .mesos.ACL.Entity hostnames = 3;
inline bool ACL_HTTPGet::has_hostnames() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ACL_HTTPGet::set_has_hostnames() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ACL_HTTPGet::clear_has_hostnames() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ACL_HTTPGet::clear_hostnames() {
  if (hostnames_ != NULL) hostnames_->::mesos::ACL_Entity::Clear();
  clear_has_hostnames();
}
inline const ::mesos::ACL_Entity& ACL_HTTPGet::hostnames() const {
  return hostnames_ != NULL ? *hostnames_ : *default_instance_->hostnames_;
}
inline ::mesos::ACL_Entity* ACL_HTTPGet::mutable_hostnames() {
  set_has_hostnames();
  if (hostnames_ == NULL) hostnames_ = new ::mesos::ACL_Entity;
  return hostnames_;
}
inline ::mesos::ACL_Entity* ACL_HTTPGet::release_hostnames() {
  clear_has_hostnames();
  ::mesos::ACL_Entity* temp = hostnames_;
  hostnames_ = NULL;
  return temp;
}
inline void ACL_HTTPGet::set_allocated_hostnames(::mesos::ACL_Entity* hostnames) {
  delete hostnames_;
  hostnames_ = hostnames;
  if (hostnames) {
    set_has_hostnames();
  } else {
    clear_has_hostnames();
  }
}

// required .mesos.ACL.Entity urls = 4;
inline bool ACL_HTTPGet::has_urls() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ACL_HTTPGet::set_has_urls() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ACL_HTTPGet::clear_has_urls() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ACL_HTTPGet::clear_urls() {
  if (urls_ != NULL) urls_->::mesos::ACL_Entity::Clear();
  clear_has_urls();
}
inline const ::mesos::ACL_Entity& ACL_HTTPGet::urls() const {
  return urls_ != NULL ? *urls_ : *default_instance_->urls_;
}
inline ::mesos::ACL_Entity* ACL_HTTPGet::mutable_urls() {
  set_has_urls();
  if (urls_ == NULL) urls_ = new ::mesos::ACL_Entity;
  return urls_;
}
inline ::mesos::ACL_Entity* ACL_HTTPGet::release_urls() {
  clear_has_urls();
  ::mesos::ACL_Entity* temp = urls_;
  urls_ = NULL;
  return temp;
}
inline void ACL_HTTPGet::set_allocated_urls(::mesos::ACL_Entity* urls) {
  delete urls_;
  urls_ = urls;
  if (urls) {
    set_has_urls();
  } else {
    clear_has_urls();
  }
}

// -------------------------------------------------------------------

// ACL_HTTPPut

// optional .mesos.ACL.Entity usernames = 1;
inline bool ACL_HTTPPut::has_usernames() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACL_HTTPPut::set_has_usernames() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACL_HTTPPut::clear_has_usernames() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACL_HTTPPut::clear_usernames() {
  if (usernames_ != NULL) usernames_->::mesos::ACL_Entity::Clear();
  clear_has_usernames();
}
inline const ::mesos::ACL_Entity& ACL_HTTPPut::usernames() const {
  return usernames_ != NULL ? *usernames_ : *default_instance_->usernames_;
}
inline ::mesos::ACL_Entity* ACL_HTTPPut::mutable_usernames() {
  set_has_usernames();
  if (usernames_ == NULL) usernames_ = new ::mesos::ACL_Entity;
  return usernames_;
}
inline ::mesos::ACL_Entity* ACL_HTTPPut::release_usernames() {
  clear_has_usernames();
  ::mesos::ACL_Entity* temp = usernames_;
  usernames_ = NULL;
  return temp;
}
inline void ACL_HTTPPut::set_allocated_usernames(::mesos::ACL_Entity* usernames) {
  delete usernames_;
  usernames_ = usernames;
  if (usernames) {
    set_has_usernames();
  } else {
    clear_has_usernames();
  }
}

// optional .mesos.ACL.Entity ips = 2;
inline bool ACL_HTTPPut::has_ips() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACL_HTTPPut::set_has_ips() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACL_HTTPPut::clear_has_ips() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACL_HTTPPut::clear_ips() {
  if (ips_ != NULL) ips_->::mesos::ACL_Entity::Clear();
  clear_has_ips();
}
inline const ::mesos::ACL_Entity& ACL_HTTPPut::ips() const {
  return ips_ != NULL ? *ips_ : *default_instance_->ips_;
}
inline ::mesos::ACL_Entity* ACL_HTTPPut::mutable_ips() {
  set_has_ips();
  if (ips_ == NULL) ips_ = new ::mesos::ACL_Entity;
  return ips_;
}
inline ::mesos::ACL_Entity* ACL_HTTPPut::release_ips() {
  clear_has_ips();
  ::mesos::ACL_Entity* temp = ips_;
  ips_ = NULL;
  return temp;
}
inline void ACL_HTTPPut::set_allocated_ips(::mesos::ACL_Entity* ips) {
  delete ips_;
  ips_ = ips;
  if (ips) {
    set_has_ips();
  } else {
    clear_has_ips();
  }
}

// optional .mesos.ACL.Entity hostnames = 3;
inline bool ACL_HTTPPut::has_hostnames() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ACL_HTTPPut::set_has_hostnames() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ACL_HTTPPut::clear_has_hostnames() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ACL_HTTPPut::clear_hostnames() {
  if (hostnames_ != NULL) hostnames_->::mesos::ACL_Entity::Clear();
  clear_has_hostnames();
}
inline const ::mesos::ACL_Entity& ACL_HTTPPut::hostnames() const {
  return hostnames_ != NULL ? *hostnames_ : *default_instance_->hostnames_;
}
inline ::mesos::ACL_Entity* ACL_HTTPPut::mutable_hostnames() {
  set_has_hostnames();
  if (hostnames_ == NULL) hostnames_ = new ::mesos::ACL_Entity;
  return hostnames_;
}
inline ::mesos::ACL_Entity* ACL_HTTPPut::release_hostnames() {
  clear_has_hostnames();
  ::mesos::ACL_Entity* temp = hostnames_;
  hostnames_ = NULL;
  return temp;
}
inline void ACL_HTTPPut::set_allocated_hostnames(::mesos::ACL_Entity* hostnames) {
  delete hostnames_;
  hostnames_ = hostnames;
  if (hostnames) {
    set_has_hostnames();
  } else {
    clear_has_hostnames();
  }
}

// required .mesos.ACL.Entity urls = 4;
inline bool ACL_HTTPPut::has_urls() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ACL_HTTPPut::set_has_urls() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ACL_HTTPPut::clear_has_urls() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ACL_HTTPPut::clear_urls() {
  if (urls_ != NULL) urls_->::mesos::ACL_Entity::Clear();
  clear_has_urls();
}
inline const ::mesos::ACL_Entity& ACL_HTTPPut::urls() const {
  return urls_ != NULL ? *urls_ : *default_instance_->urls_;
}
inline ::mesos::ACL_Entity* ACL_HTTPPut::mutable_urls() {
  set_has_urls();
  if (urls_ == NULL) urls_ = new ::mesos::ACL_Entity;
  return urls_;
}
inline ::mesos::ACL_Entity* ACL_HTTPPut::release_urls() {
  clear_has_urls();
  ::mesos::ACL_Entity* temp = urls_;
  urls_ = NULL;
  return temp;
}
inline void ACL_HTTPPut::set_allocated_urls(::mesos::ACL_Entity* urls) {
  delete urls_;
  urls_ = urls;
  if (urls) {
    set_has_urls();
  } else {
    clear_has_urls();
  }
}

// -------------------------------------------------------------------

// ACL

// -------------------------------------------------------------------

// ACLs

// optional bool permissive = 1 [default = true];
inline bool ACLs::has_permissive() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACLs::set_has_permissive() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACLs::clear_has_permissive() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACLs::clear_permissive() {
  permissive_ = true;
  clear_has_permissive();
}
inline bool ACLs::permissive() const {
  return permissive_;
}
inline void ACLs::set_permissive(bool value) {
  set_has_permissive();
  permissive_ = value;
}

// repeated .mesos.ACL.RunTasks run_tasks = 2;
inline int ACLs::run_tasks_size() const {
  return run_tasks_.size();
}
inline void ACLs::clear_run_tasks() {
  run_tasks_.Clear();
}
inline const ::mesos::ACL_RunTasks& ACLs::run_tasks(int index) const {
  return run_tasks_.Get(index);
}
inline ::mesos::ACL_RunTasks* ACLs::mutable_run_tasks(int index) {
  return run_tasks_.Mutable(index);
}
inline ::mesos::ACL_RunTasks* ACLs::add_run_tasks() {
  return run_tasks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_RunTasks >&
ACLs::run_tasks() const {
  return run_tasks_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ACL_RunTasks >*
ACLs::mutable_run_tasks() {
  return &run_tasks_;
}

// repeated .mesos.ACL.ReceiveOffers receive_offers = 3;
inline int ACLs::receive_offers_size() const {
  return receive_offers_.size();
}
inline void ACLs::clear_receive_offers() {
  receive_offers_.Clear();
}
inline const ::mesos::ACL_ReceiveOffers& ACLs::receive_offers(int index) const {
  return receive_offers_.Get(index);
}
inline ::mesos::ACL_ReceiveOffers* ACLs::mutable_receive_offers(int index) {
  return receive_offers_.Mutable(index);
}
inline ::mesos::ACL_ReceiveOffers* ACLs::add_receive_offers() {
  return receive_offers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_ReceiveOffers >&
ACLs::receive_offers() const {
  return receive_offers_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ACL_ReceiveOffers >*
ACLs::mutable_receive_offers() {
  return &receive_offers_;
}

// repeated .mesos.ACL.HTTPGet http_get = 4;
inline int ACLs::http_get_size() const {
  return http_get_.size();
}
inline void ACLs::clear_http_get() {
  http_get_.Clear();
}
inline const ::mesos::ACL_HTTPGet& ACLs::http_get(int index) const {
  return http_get_.Get(index);
}
inline ::mesos::ACL_HTTPGet* ACLs::mutable_http_get(int index) {
  return http_get_.Mutable(index);
}
inline ::mesos::ACL_HTTPGet* ACLs::add_http_get() {
  return http_get_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_HTTPGet >&
ACLs::http_get() const {
  return http_get_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ACL_HTTPGet >*
ACLs::mutable_http_get() {
  return &http_get_;
}

// repeated .mesos.ACL.HTTPPut http_put = 5;
inline int ACLs::http_put_size() const {
  return http_put_.size();
}
inline void ACLs::clear_http_put() {
  http_put_.Clear();
}
inline const ::mesos::ACL_HTTPPut& ACLs::http_put(int index) const {
  return http_put_.Get(index);
}
inline ::mesos::ACL_HTTPPut* ACLs::mutable_http_put(int index) {
  return http_put_.Mutable(index);
}
inline ::mesos::ACL_HTTPPut* ACLs::add_http_put() {
  return http_put_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::ACL_HTTPPut >&
ACLs::http_put() const {
  return http_put_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::ACL_HTTPPut >*
ACLs::mutable_http_put() {
  return &http_put_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace mesos

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::Value_Type>() {
  return ::mesos::Value_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::ACL_Entity_Type>() {
  return ::mesos::ACL_Entity_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::Status>() {
  return ::mesos::Status_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mesos::TaskState>() {
  return ::mesos::TaskState_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_mesos_2eproto__INCLUDED
