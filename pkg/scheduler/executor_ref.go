package scheduler

import (
	"bytes"
	"fmt"
	"hash/crc64"
	"sort"
	"strconv"

	"github.com/gogo/protobuf/proto"

	execcfg "github.com/mesosphere/kubernetes-mesos/pkg/executor/config"
	"github.com/mesosphere/kubernetes-mesos/pkg/scheduler/uid"

	mesos "github.com/mesos/mesos-go/mesosproto"
	mutil "github.com/mesos/mesos-go/mesosutil"
)

// ExecutorRef composes a mesosproto.ExecutorInfo instance and its referential ID.
type ExecutorRef struct {
	id uid.UID
	proto *mesos.ExecutorInfo
}

// NewExecutorRef creates a new ExecutorRef that wraps the command used to spawn an executor task process.
// The default name and source are used.
// The ID is generated based on the hash of the composed mesos.ExecutorInfo.
func NewExecutorRef(command *mesos.CommandInfo) *ExecutorRef {
	proto := &mesos.ExecutorInfo{
		Name: proto.String(execcfg.DefaultInfoName),
		Source: proto.String(execcfg.DefaultInfoSource),
		Command: command,
	}
	id := uid.New(hashCode(proto), execcfg.DefaultInfoID)
	proto.ExecutorId = mutil.NewExecutorID(id.String())
	return &ExecutorRef{
		proto: proto,
		id: id,
	}
}

func (e *ExecutorRef) ID() uid.UID {
	return e.id
}

func (e *ExecutorRef) Name() string {
	return *e.proto.Name
}

func (e *ExecutorRef) Source() string {
	return *e.proto.Source
}

func (e *ExecutorRef) Command() *mesos.CommandInfo {
	return e.proto.Command
}

func (e *ExecutorRef) Data() []byte {
	return e.proto.Data
}

func (e *ExecutorRef) Proto() *mesos.ExecutorInfo {
	return e.proto
}

// compute a hashcode for ExecutorInfo that may be used as a reasonable litmus test
// with respect to compatibility across HA schedulers. the intent is that an HA scheduler
// should fail-fast if it doesn't pass this test, rather than generating (potentially many)
// errors at run-time because a Mesos master decides that the ExecutorInfo generated by a
// secondary scheduler doesn't match that of the primary scheduler.
//
// see https://github.com/apache/mesos/blob/0.22.0/src/common/type_utils.cpp#L110
func hashCode(info *mesos.ExecutorInfo) uint64 {
	// !!! we specifically do NOT include:
	// - Framework ID because it's a value that's initialized too late for us to use
	// - Executor ID because it's a value that includes a copy of this hash
	buf := &bytes.Buffer{}
	buf.WriteString(*info.Name)
	buf.WriteString(*info.Source)
	buf.Write(info.Data)

	cmd := info.Command
	if cmd != nil {
		buf.WriteString(cmd.GetValue())
		buf.WriteString(cmd.GetUser())
		buf.WriteString(strconv.FormatBool(cmd.GetShell()))
		if sz := len(cmd.Arguments); sz > 0 {
			x := make([]string, sz)
			copy(x, cmd.Arguments)
			sort.Strings(x)
			for _, item := range x {
				buf.WriteString(item)
			}
		}
		if vars := cmd.Environment.GetVariables(); vars != nil && len(vars) > 0 {
			names := []string{}
			e := make(map[string]string)

			for _, v := range vars {
				if name := v.GetName(); name != "" {
					names = append(names, name)
					e[name] = v.GetValue()
				}
			}
			sort.Strings(names)
			for _, n := range names {
				buf.WriteString(n)
				buf.WriteString("=")
				buf.WriteString(e[n])
			}
		}
		if uris := cmd.GetUris(); len(uris) > 0 {
			su := []string{}
			for _, uri := range uris {
				su = append(su, fmt.Sprintf("%s%t%t", uri.GetValue(), uri.GetExecutable(), uri.GetExtract()))
			}
			sort.Strings(su)
			for _, uri := range su {
				buf.WriteString(uri)
			}
		}
		//TODO(jdef) add support for Resources and Container
	}
	table := crc64.MakeTable(crc64.ECMA)
	return crc64.Checksum(buf.Bytes(), table)
}
